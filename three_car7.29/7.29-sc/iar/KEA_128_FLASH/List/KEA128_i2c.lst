###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        29/Jul/2018  00:37:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  H:\智能车程序2018\三轮比赛\7.29-sc\lib\C\KEA128_i2c.c
#    Command line =  
#        H:\智能车程序2018\三轮比赛\7.29-sc\lib\C\KEA128_i2c.c -D IAR -D
#        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -lCN
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\KEA_128_FLASH\List\ -lB
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\KEA_128_FLASH\List\ -o
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\KEA_128_FLASH\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None
#        --dlib_config F:\IAR安装包\arm\INC\c\DLib_Config_Normal.h -I
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\..\device\H\ -I
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\..\user\H\ -I
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\..\system\ -I
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\..\lib\H\ -I
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\..\system\coreSupport\ -On
#    List file    =  
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\KEA_128_FLASH\List\KEA128_i2c.lst
#    Object file  =  
#        H:\智能车程序2018\三轮比赛\7.29-sc\iar\KEA_128_FLASH\Obj\KEA128_i2c.o
#
###############################################################################

H:\智能车程序2018\三轮比赛\7.29-sc\lib\C\KEA128_i2c.c
      1          /*********************************************************************************************************************
      2           * COPYRIGHT NOTICE
      3           * Copyright (c) 2017,逐飞科技
      4           * All rights reserved.
      5           * 技术讨论QQ群：179029047
      6           *
      7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
      8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
      9           *
     10           * @file       		KEA128_i2c
     11           * @company	   		成都逐飞科技有限公司
     12           * @author     		逐飞科技(QQ3184284598)
     13           * @version    		v2.0
     14           * @Software 		IAR 7.7 or MDK 5.23
     15           * @Target core		S9KEA128AMLK
     16           * @Taobao   		https://seekfree.taobao.com/
     17           * @date       		2017-11-6
     18           ********************************************************************************************************************/
     19          
     20          
     21          #include "KEA128_i2c.h"
     22          

   \                                 In section .bss, align 1
     23          unsigned char MasterTransmission;
   \                     MasterTransmission:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     24          unsigned char SlaveID;
   \                     SlaveID:
   \   00000000                      DS8 1
     25          

   \                                 In section .data, align 4
     26          I2C_Type * I2CN[2] = I2C_BASES; //定义两个指针数组保存 I2CN 的地址
   \                     I2CN:
   \   00000000   0x40066000         DC32 40066000H, 40067000H
   \              0x40067000   
     27          
     28          
     29          //等待 I2C_S  不会出现卡死的情况

   \                                 In section .text, align 2, keep-with-next
     30          void i2c_Wait(I2Cn_e i2cn)
     31          {
   \                     i2c_Wait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     32              uint16 num;
     33              uint16 wait_num=500;//等待次数，超过设定的次数将关闭硬件IIC，使用模拟IIC发出stop信号，然后在启动硬件IIC。
   \   00000004   0x26FA             MOVS     R6,#+250
   \   00000006   0x0076             LSLS     R6,R6,#+1        ;; #+500
     34                                  //这里的500在通信速率为100K的时候可以正常使用，如果通信速率较低可以适当增加这个值。
     35                                  //经过测试可以在通信出错的时候，自动恢复。
     36              while(( I2CN[i2cn]->S & I2C_S_IICIF_MASK)==0)
   \                     ??i2c_Wait_0: (+1)
   \   00000008   0x....             LDR      R0,??DataTable2
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4361             MULS     R1,R4,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x78C0             LDRB     R0,[R0, #+3]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD445             BMI      ??i2c_Wait_1
     37              {
     38                  num++;
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
     39                  if(num>wait_num)
   \   0000001A   0xB2B6             UXTH     R6,R6
   \   0000001C   0xB2AD             UXTH     R5,R5
   \   0000001E   0x42AE             CMP      R6,R5
   \   00000020   0xD2F2             BCS      ??i2c_Wait_0
     40                  {
     41                      I2CN[i2cn]->C1 = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable2
   \   00000026   0xB2E4             UXTB     R4,R4
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0x4362             MULS     R2,R4,R2
   \   0000002C   0x5889             LDR      R1,[R1, R2]
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
     42                      if(i2cn == i2c0)    SIM->SCGC &= ~(uint32)SIM_SCGC_I2C0_MASK;
   \   00000030   0xB2E4             UXTB     R4,R4
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD106             BNE      ??i2c_Wait_2
   \   00000036   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x....             LDR      R1,??DataTable2_2  ;; 0xfffeffff
   \   0000003C   0x4001             ANDS     R1,R1,R0
   \   0000003E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0xE005             B        ??i2c_Wait_3
     43                      else                SIM->SCGC &= ~(uint32)SIM_SCGC_I2C1_MASK;
   \                     ??i2c_Wait_2: (+1)
   \   00000044   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x....             LDR      R1,??DataTable2_3  ;; 0xfffdffff
   \   0000004A   0x4001             ANDS     R1,R1,R0
   \   0000004C   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000004E   0x6001             STR      R1,[R0, #+0]
     44          
     45                      LED_3_ON;//出错了，闪灯
   \                     ??i2c_Wait_3: (+1)
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2033             MOVS     R0,#+51
   \   00000054   0x.... 0x....      BL       GpioSet
     46                      iic_error++;
   \   00000058   0x....             LDR      R0,??DataTable2_4
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x....             LDR      R1,??DataTable2_4
   \   00000060   0x6008             STR      R0,[R1, #+0]
     47                      iic_error_counter++;
   \   00000062   0x....             LDR      R0,??DataTable2_5
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR      R1,??DataTable2_5
   \   0000006A   0x6008             STR      R0,[R1, #+0]
     48          //            BUZZER_TURN;
     49                      carStatus = STOP;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x....             LDR      R1,??DataTable2_6
   \   00000070   0x7008             STRB     R0,[R1, #+0]
     50          //            IIC_init();
     51          //            IIC_stop();
     52                      if(i2cn == i2c0)    SIM->SCGC |= SIM_SCGC_I2C0_MASK;
   \   00000072   0xB2E4             UXTB     R4,R4
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD107             BNE      ??i2c_Wait_4
   \   00000078   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x2180             MOVS     R1,#+128
   \   0000007E   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000080   0x4301             ORRS     R1,R1,R0
   \   00000082   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000084   0x6001             STR      R1,[R0, #+0]
   \   00000086   0xE006             B        ??i2c_Wait_5
     53                      else                SIM->SCGC |= SIM_SCGC_I2C1_MASK;
   \                     ??i2c_Wait_4: (+1)
   \   00000088   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x2180             MOVS     R1,#+128
   \   0000008E   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   00000090   0x4301             ORRS     R1,R1,R0
   \   00000092   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000094   0x6001             STR      R1,[R0, #+0]
     54                      I2CN[i2cn]->C1 = I2C_C1_IICEN_MASK;
   \                     ??i2c_Wait_5: (+1)
   \   00000096   0x2080             MOVS     R0,#+128
   \   00000098   0x....             LDR      R1,??DataTable2
   \   0000009A   0xB2E4             UXTB     R4,R4
   \   0000009C   0x2204             MOVS     R2,#+4
   \   0000009E   0x4362             MULS     R2,R4,R2
   \   000000A0   0x5889             LDR      R1,[R1, R2]
   \   000000A2   0x7088             STRB     R0,[R1, #+2]
     55                      break;
     56                  }
     57              }
     58              I2CN[i2cn]->S |= I2C_S_IICIF_MASK ;
   \                     ??i2c_Wait_1: (+1)
   \   000000A4   0x....             LDR      R0,??DataTable2
   \   000000A6   0xB2E4             UXTB     R4,R4
   \   000000A8   0x2104             MOVS     R1,#+4
   \   000000AA   0x4361             MULS     R1,R4,R1
   \   000000AC   0x5840             LDR      R0,[R0, R1]
   \   000000AE   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B0   0x2102             MOVS     R1,#+2
   \   000000B2   0x4301             ORRS     R1,R1,R0
   \   000000B4   0x....             LDR      R0,??DataTable2
   \   000000B6   0xB2E4             UXTB     R4,R4
   \   000000B8   0x2204             MOVS     R2,#+4
   \   000000BA   0x4362             MULS     R2,R4,R2
   \   000000BC   0x5880             LDR      R0,[R0, R2]
   \   000000BE   0x70C1             STRB     R1,[R0, #+3]
     59          }
   \   000000C0   0xBD70             POP      {R4-R6,PC}       ;; return
     60          
     61          //启动信号
     62          #define i2c_Start(NUM)             {I2CN[NUM]->C1 |= (I2C_C1_TX_MASK | I2C_C1_MST_MASK);}    //MST 由0变1，产生起始信号，TX = 1 进入发送模式
     63          
     64          //停止信号
     65          #define i2c_Stop(NUM)              {I2CN[NUM]->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK);}   //MST 由1变0，产生停止信号，TX = 0 进入接收模式
     66          
     67          //重复启动
     68          #define i2c_RepeatedStart(NUM)     {I2CN[NUM]->C1 |= I2C_C1_RSTA_MASK;}
     69          
     70          //进入接收模式(应答,需要接收多个数据，接收最后一个字节前需要禁用应答i2c_DisableAck)
     71          #define i2c_EnterRxMode(NUM)       {I2CN[NUM]->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);}  //
     72          
     73          //进入接收模式(不应答,只接收一个字节)
     74          #define i2c_PutinRxMode(NUM)       {I2CN[NUM]->C1 &= ~I2C_C1_TX_MASK; I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
     75          
     76          //禁用应答(接收最后一个字节)
     77          #define i2c_DisableAck(NUM)        {I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
     78          
     79          //写一个字节
     80          #define i2c_write_byte(NUM,data)   {I2CN[NUM]->D = data; i2c_Wait(NUM);}
     81          
     82          
     83          
     84          
     85          //-------------------------------------------------------------------------------------------------------------------
     86          //  @brief      I2C初始化
     87          //  @param      i2cn        I2C模块(i2c0,i2c1)
     88          //  @param      baud        期望的波特率
     89          //  @return                 实际的波特率
     90          //  @return     void
     91          //  @since      v2.0
     92          //  Sample usage:           i2c_init(i2c0,400*1000);     // 初始化i2c0，期望的波特率为400k
     93          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     94          uint32 i2c_init(I2Cn_e i2cn, uint32 baud)
     95          {
   \                     i2c_init: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB0A2             SUB      SP,SP,#+136
   \   00000004   0x0007             MOVS     R7,R0
     96              //查表 ICR 对应的  SCL_divider ，见 《KEA128RM.pdf》第537页的I2C 分频器和保持值
     97              uint16 ICR_2_SCL_divider[0x40]  =
     98              {
     99                  20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68,
    100                  48, 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240,
    101                  160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576, 640, 768, 960,
    102                  640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840
    103              };
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x....             LDR      R1,??DataTable2_7
   \   0000000A   0x2280             MOVS     R2,#+128
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    104          
    105              uint8 mult;
    106          
    107              uint16 scldiv =  0;  //最佳的分频系数
   \   00000010   0x2600             MOVS     R6,#+0
    108          
    109              //需要从 ICR_2_SCL_divider 里找到 与最佳分频系数scldiv最相近的 分频系数
    110              uint8 icr, n;
    111              uint16 min_Dvalue = ~0, Dvalue;
   \   00000012   0x....             LDR      R5,??DataTable2_8  ;; 0xffff
    112          
    113              if(i2cn == i2c0)
   \   00000014   0xB2FF             UXTB     R7,R7
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD10D             BNE      ??i2c_init_0
    114              {
    115                  // 开启时钟
    116                  SIM->SCGC |= SIM_SCGC_I2C0_MASK;           //开启 I2C0时钟
   \   0000001A   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2180             MOVS     R1,#+128
   \   00000020   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000022   0x4301             ORRS     R1,R1,R0
   \   00000024   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000026   0x6001             STR      R1,[R0, #+0]
    117                  //复用引脚
    118                  if(A3 == I2C0_SCL_PIN)
    119                  {
    120                      SIM->PINSEL &= ~(uint32)SIM_PINSEL_I2C0PS_MASK;
   \   00000028   0x....             LDR      R0,??DataTable2_9  ;; 0x4004800c
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x4388             BICS     R0,R0,R1
   \   00000030   0x....             LDR      R1,??DataTable2_9  ;; 0x4004800c
   \   00000032   0x6008             STR      R0,[R1, #+0]
   \   00000034   0xE00D             B        ??i2c_init_1
    121                  }
    122                  else
    123                  {
    124                      SIM->PINSEL |= SIM_PINSEL_I2C0PS_MASK;
    125                  }
    126          
    127              }
    128              else
    129              {
    130                  // 开启时钟
    131                  SIM->SCGC |= SIM_SCGC_I2C1_MASK;           //开启 I2C1时钟
   \                     ??i2c_init_0: (+1)
   \   00000036   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2180             MOVS     R1,#+128
   \   0000003C   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   0000003E   0x4301             ORRS     R1,R1,R0
   \   00000040   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000042   0x6001             STR      R1,[R0, #+0]
    132                  //复用引脚
    133                  if(E1 == I2C1_SCL_PIN)
    134                  {
    135                      SIM->PINSEL1 &= ~(uint32)SIM_PINSEL1_I2C1PS_MASK;
    136                  }
    137                  else
    138                  {
    139                      SIM->PINSEL1 |= SIM_PINSEL1_I2C1PS_MASK;
   \   00000044   0x....             LDR      R0,??DataTable2_10  ;; 0x40048010
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   0000004C   0x4301             ORRS     R1,R1,R0
   \   0000004E   0x....             LDR      R0,??DataTable2_10  ;; 0x40048010
   \   00000050   0x6001             STR      R1,[R0, #+0]
    140                  }
    141              }
    142          
    143              // 设置频率
    144          
    145              // I2C baud rate = bus speed (Hz)/(mul × SCL divider)
    146              // SDA hold time = bus period (s) × mul × SDA hold value
    147              // SCL start hold time = bus period (s) × mul × SCL start hold value
    148              // SCL stop hold time = bus period (s) × mul × SCL stop hold value
    149          
    150          
    151              mult = bus_clk_khz*1000/baud/3840;
   \                     ??i2c_init_1: (+1)
   \   00000052   0x....             LDR      R0,??DataTable3
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x21FA             MOVS     R1,#+250
   \   00000058   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   0000005A   0x4348             MULS     R0,R1,R0
   \   0000005C   0x9922             LDR      R1,[SP, #+136]
   \   0000005E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000062   0x21F0             MOVS     R1,#+240
   \   00000064   0x0109             LSLS     R1,R1,#+4        ;; #+3840
   \   00000066   0x.... 0x....      BL       __aeabi_uidiv
   \   0000006A   0x4669             MOV      R1,SP
   \   0000006C   0x7048             STRB     R0,[R1, #+1]
    152          
    153              scldiv =  bus_clk_khz * 1000 / ( (1<<mult) * baud );    //最佳的分频系数
   \   0000006E   0x....             LDR      R0,??DataTable3
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x21FA             MOVS     R1,#+250
   \   00000074   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000076   0x4348             MULS     R0,R1,R0
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x466A             MOV      R2,SP
   \   0000007C   0x7852             LDRB     R2,[R2, #+1]
   \   0000007E   0x4091             LSLS     R1,R1,R2
   \   00000080   0x9A22             LDR      R2,[SP, #+136]
   \   00000082   0x4351             MULS     R1,R2,R1
   \   00000084   0x.... 0x....      BL       __aeabi_uidiv
   \   00000088   0x0006             MOVS     R6,R0
    154          
    155              n = 0x40;
   \   0000008A   0x2040             MOVS     R0,#+64
   \   0000008C   0x0004             MOVS     R4,R0
    156              while(n)                                                //循环里逐个扫描，找出最接近的 分频系数
   \                     ??i2c_init_2: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD01D             BEQ      ??i2c_init_3
    157              {
    158                  n--;
   \   00000094   0x1E64             SUBS     R4,R4,#+1
    159                  Dvalue = abs(scldiv - ICR_2_SCL_divider[n]);
   \   00000096   0xB2B6             UXTH     R6,R6
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0xB2E4             UXTB     R4,R4
   \   0000009C   0x2102             MOVS     R1,#+2
   \   0000009E   0x4361             MULS     R1,R4,R1
   \   000000A0   0x5A40             LDRH     R0,[R0, R1]
   \   000000A2   0x1A30             SUBS     R0,R6,R0
   \   000000A4   0x.... 0x....      BL       abs
   \   000000A8   0x4669             MOV      R1,SP
   \   000000AA   0x8048             STRH     R0,[R1, #+2]
    160                  if(Dvalue == 0)
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x8840             LDRH     R0,[R0, #+2]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD102             BNE      ??i2c_init_4
    161                  {
    162                      icr = n;
   \   000000B4   0x4668             MOV      R0,SP
   \   000000B6   0x7004             STRB     R4,[R0, #+0]
    163                      break;                                          //退出while循环
   \   000000B8   0xE00A             B        ??i2c_init_3
    164                  }
    165          
    166                  if(Dvalue < min_Dvalue)
   \                     ??i2c_init_4: (+1)
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x8840             LDRH     R0,[R0, #+2]
   \   000000BE   0xB2AD             UXTH     R5,R5
   \   000000C0   0x42A8             CMP      R0,R5
   \   000000C2   0xD2E4             BCS      ??i2c_init_2
    167                  {
    168                      icr = n;
   \   000000C4   0x4668             MOV      R0,SP
   \   000000C6   0x7004             STRB     R4,[R0, #+0]
    169                      min_Dvalue = Dvalue;
   \   000000C8   0x4668             MOV      R0,SP
   \   000000CA   0x8840             LDRH     R0,[R0, #+2]
   \   000000CC   0x0005             MOVS     R5,R0
   \   000000CE   0xE7DE             B        ??i2c_init_2
    170                  }
    171              }
    172          
    173              I2CN[i2cn]->F  = I2C_F_MULT(mult) | I2C_F_ICR(icr);     // I2C分频寄存器
   \                     ??i2c_init_3: (+1)
   \   000000D0   0x4668             MOV      R0,SP
   \   000000D2   0x7840             LDRB     R0,[R0, #+1]
   \   000000D4   0x0181             LSLS     R1,R0,#+6
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   000000DC   0x0E80             LSRS     R0,R0,#+26
   \   000000DE   0x4308             ORRS     R0,R0,R1
   \   000000E0   0x....             LDR      R1,??DataTable2
   \   000000E2   0xB2FF             UXTB     R7,R7
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0x437A             MULS     R2,R7,R2
   \   000000E8   0x5889             LDR      R1,[R1, R2]
   \   000000EA   0x7048             STRB     R0,[R1, #+1]
    174          
    175              // 使能 I2C
    176              I2CN[i2cn]->C1 = ( 0
    177                                 | I2C_C1_IICEN_MASK       //使能I2C
    178                                 //| I2C_C1_IICIE_MASK       //使能中断
    179                               );
   \   000000EC   0x2080             MOVS     R0,#+128
   \   000000EE   0x....             LDR      R1,??DataTable2
   \   000000F0   0xB2FF             UXTB     R7,R7
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0x437A             MULS     R2,R7,R2
   \   000000F6   0x5889             LDR      R1,[R1, R2]
   \   000000F8   0x7088             STRB     R0,[R1, #+2]
    180          
    181              return (  bus_clk_khz * 1000 / ( (1<<mult) * ICR_2_SCL_divider[icr])  );
   \   000000FA   0x....             LDR      R0,??DataTable3
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x21FA             MOVS     R1,#+250
   \   00000100   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000102   0x4348             MULS     R0,R1,R0
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0x466A             MOV      R2,SP
   \   00000108   0x7852             LDRB     R2,[R2, #+1]
   \   0000010A   0x4091             LSLS     R1,R1,R2
   \   0000010C   0xAA01             ADD      R2,SP,#+4
   \   0000010E   0x4694             MOV      R12,R2
   \   00000110   0x466A             MOV      R2,SP
   \   00000112   0x7813             LDRB     R3,[R2, #+0]
   \   00000114   0x2202             MOVS     R2,#+2
   \   00000116   0x4353             MULS     R3,R2,R3
   \   00000118   0x4662             MOV      R2,R12
   \   0000011A   0x5AD2             LDRH     R2,[R2, R3]
   \   0000011C   0x4351             MULS     R1,R2,R1
   \   0000011E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000122   0xB023             ADD      SP,SP,#+140
   \   00000124   0xBDF0             POP      {R4-R7,PC}       ;; return
    182          }
    183          
    184          //-------------------------------------------------------------------------------------------------------------------
    185          //  @brief      I2C通信结束后需要调用的函数函数
    186          //  @return     void
    187          //  @since      v2.0
    188          //  @note		如果通信失败，可尝试增大此延时值，确认是否延时导致的
    189          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    190          void i2c_delay(void)
    191          {
   \                     i2c_delay: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    192              volatile uint16 n = 150;     //注意，这个数据太小，会导致读取错误。
   \   00000002   0x2096             MOVS     R0,#+150
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    193          
    194              while(n--);
   \                     ??i2c_delay_0: (+1)
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x1E41             SUBS     R1,R0,#+1
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x8011             STRH     R1,[R2, #+0]
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1F7             BNE      ??i2c_delay_0
    195          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    196          
    197          //-------------------------------------------------------------------------------------------------------------------
    198          //  @brief      读取I2C设备指定地址寄存器的数据
    199          //  @param      i2cn        I2C模块(i2c0、i2c1)
    200          //  @param      SlaveID     从机地址(7位地址)
    201          //  @param      reg         从机寄存器地址
    202          //  @return                 读取的寄存器值
    203          //  @since      v2.0
    204          //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50);//读取0x50地址的数据，从机地址为0x2D
    205          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    206          uint8 i2c_read_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg)
    207          {
   \                     i2c_read_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
    208          
    209              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    210              //地址是低七位
    211              uint8 result;
    212          
    213              i2c_Start(i2cn);                                    //发送启动信号
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4361             MULS     R1,R4,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x2030             MOVS     R0,#+48
   \   00000016   0x4308             ORRS     R0,R0,R1
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x4362             MULS     R2,R4,R2
   \   00000020   0x5889             LDR      R1,[R1, R2]
   \   00000022   0x7088             STRB     R0,[R1, #+2]
    214          
    215              i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
   \   00000024   0x0068             LSLS     R0,R5,#+1
   \   00000026   0x....             LDR      R1,??DataTable4
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0x4362             MULS     R2,R4,R2
   \   0000002E   0x5889             LDR      R1,[R1, R2]
   \   00000030   0x7108             STRB     R0,[R1, #+4]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x.... 0x....      BL       i2c_Wait
    216          
    217              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003A   0x....             LDR      R0,??DataTable4
   \   0000003C   0xB2E4             UXTB     R4,R4
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x4361             MULS     R1,R4,R1
   \   00000042   0x5840             LDR      R0,[R0, R1]
   \   00000044   0x7107             STRB     R7,[R0, #+4]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       i2c_Wait
    218          
    219              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   0000004E   0x....             LDR      R0,??DataTable4
   \   00000050   0xB2E4             UXTB     R4,R4
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x4361             MULS     R1,R4,R1
   \   00000056   0x5840             LDR      R0,[R0, R1]
   \   00000058   0x7881             LDRB     R1,[R0, #+2]
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x4308             ORRS     R0,R0,R1
   \   0000005E   0x....             LDR      R1,??DataTable4
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0x2204             MOVS     R2,#+4
   \   00000064   0x4362             MULS     R2,R4,R2
   \   00000066   0x5889             LDR      R1,[R1, R2]
   \   00000068   0x7088             STRB     R0,[R1, #+2]
    220          
    221              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   0000006A   0x0069             LSLS     R1,R5,#+1
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x4308             ORRS     R0,R0,R1
   \   00000070   0x....             LDR      R1,??DataTable4
   \   00000072   0xB2E4             UXTB     R4,R4
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x4362             MULS     R2,R4,R2
   \   00000078   0x5889             LDR      R1,[R1, R2]
   \   0000007A   0x7108             STRB     R0,[R1, #+4]
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x.... 0x....      BL       i2c_Wait
    222          
    223              i2c_PutinRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   00000084   0x....             LDR      R0,??DataTable4
   \   00000086   0xB2E4             UXTB     R4,R4
   \   00000088   0x2104             MOVS     R1,#+4
   \   0000008A   0x4361             MULS     R1,R4,R1
   \   0000008C   0x5840             LDR      R0,[R0, R1]
   \   0000008E   0x7881             LDRB     R1,[R0, #+2]
   \   00000090   0x20EF             MOVS     R0,#+239
   \   00000092   0x4008             ANDS     R0,R0,R1
   \   00000094   0x....             LDR      R1,??DataTable4
   \   00000096   0xB2E4             UXTB     R4,R4
   \   00000098   0x2204             MOVS     R2,#+4
   \   0000009A   0x4362             MULS     R2,R4,R2
   \   0000009C   0x5889             LDR      R1,[R1, R2]
   \   0000009E   0x7088             STRB     R0,[R1, #+2]
   \   000000A0   0x....             LDR      R0,??DataTable4
   \   000000A2   0xB2E4             UXTB     R4,R4
   \   000000A4   0x2104             MOVS     R1,#+4
   \   000000A6   0x4361             MULS     R1,R4,R1
   \   000000A8   0x5840             LDR      R0,[R0, R1]
   \   000000AA   0x7881             LDRB     R1,[R0, #+2]
   \   000000AC   0x2008             MOVS     R0,#+8
   \   000000AE   0x4308             ORRS     R0,R0,R1
   \   000000B0   0x....             LDR      R1,??DataTable4
   \   000000B2   0xB2E4             UXTB     R4,R4
   \   000000B4   0x2204             MOVS     R2,#+4
   \   000000B6   0x4362             MULS     R2,R4,R2
   \   000000B8   0x5889             LDR      R1,[R1, R2]
   \   000000BA   0x7088             STRB     R0,[R1, #+2]
    224              result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
   \   000000BC   0x....             LDR      R0,??DataTable4
   \   000000BE   0xB2E4             UXTB     R4,R4
   \   000000C0   0x2104             MOVS     R1,#+4
   \   000000C2   0x4361             MULS     R1,R4,R1
   \   000000C4   0x5840             LDR      R0,[R0, R1]
   \   000000C6   0x7900             LDRB     R0,[R0, #+4]
   \   000000C8   0x0006             MOVS     R6,R0
    225              i2c_Wait(i2cn);                                     //等待接收完成
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0xB2C0             UXTB     R0,R0
   \   000000CE   0x.... 0x....      BL       i2c_Wait
    226          
    227              i2c_Stop(i2cn);                                     //发送停止信号
   \   000000D2   0x....             LDR      R0,??DataTable4
   \   000000D4   0xB2E4             UXTB     R4,R4
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x4361             MULS     R1,R4,R1
   \   000000DA   0x5840             LDR      R0,[R0, R1]
   \   000000DC   0x7881             LDRB     R1,[R0, #+2]
   \   000000DE   0x20CF             MOVS     R0,#+207
   \   000000E0   0x4008             ANDS     R0,R0,R1
   \   000000E2   0x....             LDR      R1,??DataTable4
   \   000000E4   0xB2E4             UXTB     R4,R4
   \   000000E6   0x2204             MOVS     R2,#+4
   \   000000E8   0x4362             MULS     R2,R4,R2
   \   000000EA   0x5889             LDR      R1,[R1, R2]
   \   000000EC   0x7088             STRB     R0,[R1, #+2]
    228          
    229              result = I2CN[i2cn]->D;                             //读取数据
   \   000000EE   0x....             LDR      R0,??DataTable4
   \   000000F0   0xB2E4             UXTB     R4,R4
   \   000000F2   0x2104             MOVS     R1,#+4
   \   000000F4   0x4361             MULS     R1,R4,R1
   \   000000F6   0x5840             LDR      R0,[R0, R1]
   \   000000F8   0x7900             LDRB     R0,[R0, #+4]
   \   000000FA   0x0006             MOVS     R6,R0
    230          
    231              i2c_delay();                                        //必须延时一下，否则出错
   \   000000FC   0x.... 0x....      BL       i2c_delay
    232          
    233              return result;
   \   00000100   0x0030             MOVS     R0,R6
   \   00000102   0xB2C0             UXTB     R0,R0
   \   00000104   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    234          }
    235          
    236          //-------------------------------------------------------------------------------------------------------------------
    237          //  @brief      读取I2C设备指定地址寄存器的数据
    238          //  @param      i2cn        I2C模块(i2c0、i2c1)
    239          //  @param      SlaveID     从机地址(7位地址)
    240          //  @param      reg         从机寄存器地址
    241          //  @param      num         读取字节数
    242          //  @param      addr        读取的数据存储的地址
    243          //  @return     void
    244          //  @since      v2.0
    245          //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50, 10, buf);//读取0x50地址的数据，从机地址为0x2D开始的10个字节
    246          //-------------------------------------------------------------------------------------------------------------------
    247          

   \                                 In section .text, align 2, keep-with-next
    248          uint8 i2c_read_reg_bytes(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 num, uint8 * addr)
    249          {
   \                     i2c_read_reg_bytes: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x001C             MOVS     R4,R3
   \   00000006   0x9E08             LDR      R6,[SP, #+32]
    250              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    251              //地址是低七位
    252              uint8 result;
    253          
    254              i2c_Start(i2cn);                                    //发送启动信号
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0xB2ED             UXTB     R5,R5
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4369             MULS     R1,R5,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x2030             MOVS     R0,#+48
   \   00000016   0x4308             ORRS     R0,R0,R1
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x436A             MULS     R2,R5,R2
   \   00000020   0x5889             LDR      R1,[R1, R2]
   \   00000022   0x7088             STRB     R0,[R1, #+2]
    255          
    256              i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x7900             LDRB     R0,[R0, #+4]
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x....             LDR      R1,??DataTable4
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0x436A             MULS     R2,R5,R2
   \   00000032   0x5889             LDR      R1,[R1, R2]
   \   00000034   0x7108             STRB     R0,[R1, #+4]
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x.... 0x....      BL       i2c_Wait
    257          
    258              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x7A00             LDRB     R0,[R0, #+8]
   \   00000042   0x....             LDR      R1,??DataTable4
   \   00000044   0xB2ED             UXTB     R5,R5
   \   00000046   0x2204             MOVS     R2,#+4
   \   00000048   0x436A             MULS     R2,R5,R2
   \   0000004A   0x5889             LDR      R1,[R1, R2]
   \   0000004C   0x7108             STRB     R0,[R1, #+4]
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0
   \   00000052   0x.... 0x....      BL       i2c_Wait
    259          
    260              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   00000056   0x....             LDR      R0,??DataTable4
   \   00000058   0xB2ED             UXTB     R5,R5
   \   0000005A   0x2104             MOVS     R1,#+4
   \   0000005C   0x4369             MULS     R1,R5,R1
   \   0000005E   0x5840             LDR      R0,[R0, R1]
   \   00000060   0x7881             LDRB     R1,[R0, #+2]
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x4308             ORRS     R0,R0,R1
   \   00000066   0x....             LDR      R1,??DataTable4
   \   00000068   0xB2ED             UXTB     R5,R5
   \   0000006A   0x2204             MOVS     R2,#+4
   \   0000006C   0x436A             MULS     R2,R5,R2
   \   0000006E   0x5889             LDR      R1,[R1, R2]
   \   00000070   0x7088             STRB     R0,[R1, #+2]
    261          
    262              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x7900             LDRB     R0,[R0, #+4]
   \   00000076   0x0041             LSLS     R1,R0,#+1
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x4308             ORRS     R0,R0,R1
   \   0000007C   0x....             LDR      R1,??DataTable4
   \   0000007E   0xB2ED             UXTB     R5,R5
   \   00000080   0x2204             MOVS     R2,#+4
   \   00000082   0x436A             MULS     R2,R5,R2
   \   00000084   0x5889             LDR      R1,[R1, R2]
   \   00000086   0x7108             STRB     R0,[R1, #+4]
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0x.... 0x....      BL       i2c_Wait
    263          
    264              i2c_EnterRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   00000090   0x....             LDR      R0,??DataTable4
   \   00000092   0xB2ED             UXTB     R5,R5
   \   00000094   0x2104             MOVS     R1,#+4
   \   00000096   0x4369             MULS     R1,R5,R1
   \   00000098   0x5840             LDR      R0,[R0, R1]
   \   0000009A   0x7881             LDRB     R1,[R0, #+2]
   \   0000009C   0x20E7             MOVS     R0,#+231
   \   0000009E   0x4008             ANDS     R0,R0,R1
   \   000000A0   0x....             LDR      R1,??DataTable4
   \   000000A2   0xB2ED             UXTB     R5,R5
   \   000000A4   0x2204             MOVS     R2,#+4
   \   000000A6   0x436A             MULS     R2,R5,R2
   \   000000A8   0x5889             LDR      R1,[R1, R2]
   \   000000AA   0x7088             STRB     R0,[R1, #+2]
    265          
    266              while(num--)
   \                     ??i2c_read_reg_bytes_0: (+1)
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x1E44             SUBS     R4,R0,#+1
   \   000000B0   0xB2C0             UXTB     R0,R0
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD015             BEQ      ??i2c_read_reg_bytes_1
    267              {
    268                  result = I2CN[i2cn]->D;                         //虚假读取一次，启动接收数据
   \   000000B6   0x....             LDR      R0,??DataTable4
   \   000000B8   0xB2ED             UXTB     R5,R5
   \   000000BA   0x2104             MOVS     R1,#+4
   \   000000BC   0x4369             MULS     R1,R5,R1
   \   000000BE   0x5840             LDR      R0,[R0, R1]
   \   000000C0   0x7900             LDRB     R0,[R0, #+4]
   \   000000C2   0x0007             MOVS     R7,R0
    269                  i2c_Wait(i2cn);                                 //等待接收完成
   \   000000C4   0x0028             MOVS     R0,R5
   \   000000C6   0xB2C0             UXTB     R0,R0
   \   000000C8   0x.... 0x....      BL       i2c_Wait
    270                  *addr = I2CN[i2cn]->D;                         //读取数据
   \   000000CC   0x....             LDR      R0,??DataTable4
   \   000000CE   0xB2ED             UXTB     R5,R5
   \   000000D0   0x2104             MOVS     R1,#+4
   \   000000D2   0x4369             MULS     R1,R5,R1
   \   000000D4   0x5840             LDR      R0,[R0, R1]
   \   000000D6   0x7900             LDRB     R0,[R0, #+4]
   \   000000D8   0x7030             STRB     R0,[R6, #+0]
    271                  i2c_delay();                                    //必须延时一下，否则出错
   \   000000DA   0x.... 0x....      BL       i2c_delay
    272                  addr++;
   \   000000DE   0x1C76             ADDS     R6,R6,#+1
   \   000000E0   0xE7E4             B        ??i2c_read_reg_bytes_0
    273              }
    274              i2c_DisableAck(i2cn);
   \                     ??i2c_read_reg_bytes_1: (+1)
   \   000000E2   0x....             LDR      R0,??DataTable4
   \   000000E4   0xB2ED             UXTB     R5,R5
   \   000000E6   0x2104             MOVS     R1,#+4
   \   000000E8   0x4369             MULS     R1,R5,R1
   \   000000EA   0x5840             LDR      R0,[R0, R1]
   \   000000EC   0x7881             LDRB     R1,[R0, #+2]
   \   000000EE   0x2008             MOVS     R0,#+8
   \   000000F0   0x4308             ORRS     R0,R0,R1
   \   000000F2   0x....             LDR      R1,??DataTable4
   \   000000F4   0xB2ED             UXTB     R5,R5
   \   000000F6   0x2204             MOVS     R2,#+4
   \   000000F8   0x436A             MULS     R2,R5,R2
   \   000000FA   0x5889             LDR      R1,[R1, R2]
   \   000000FC   0x7088             STRB     R0,[R1, #+2]
    275              i2c_PutinRxMode(i2cn);
   \   000000FE   0x....             LDR      R0,??DataTable4
   \   00000100   0xB2ED             UXTB     R5,R5
   \   00000102   0x2104             MOVS     R1,#+4
   \   00000104   0x4369             MULS     R1,R5,R1
   \   00000106   0x5840             LDR      R0,[R0, R1]
   \   00000108   0x7881             LDRB     R1,[R0, #+2]
   \   0000010A   0x20EF             MOVS     R0,#+239
   \   0000010C   0x4008             ANDS     R0,R0,R1
   \   0000010E   0x....             LDR      R1,??DataTable4
   \   00000110   0xB2ED             UXTB     R5,R5
   \   00000112   0x2204             MOVS     R2,#+4
   \   00000114   0x436A             MULS     R2,R5,R2
   \   00000116   0x5889             LDR      R1,[R1, R2]
   \   00000118   0x7088             STRB     R0,[R1, #+2]
   \   0000011A   0x....             LDR      R0,??DataTable4
   \   0000011C   0xB2ED             UXTB     R5,R5
   \   0000011E   0x2104             MOVS     R1,#+4
   \   00000120   0x4369             MULS     R1,R5,R1
   \   00000122   0x5840             LDR      R0,[R0, R1]
   \   00000124   0x7881             LDRB     R1,[R0, #+2]
   \   00000126   0x2008             MOVS     R0,#+8
   \   00000128   0x4308             ORRS     R0,R0,R1
   \   0000012A   0x....             LDR      R1,??DataTable4
   \   0000012C   0xB2ED             UXTB     R5,R5
   \   0000012E   0x2204             MOVS     R2,#+4
   \   00000130   0x436A             MULS     R2,R5,R2
   \   00000132   0x5889             LDR      R1,[R1, R2]
   \   00000134   0x7088             STRB     R0,[R1, #+2]
    276              result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
   \   00000136   0x....             LDR      R0,??DataTable4
   \   00000138   0xB2ED             UXTB     R5,R5
   \   0000013A   0x2104             MOVS     R1,#+4
   \   0000013C   0x4369             MULS     R1,R5,R1
   \   0000013E   0x5840             LDR      R0,[R0, R1]
   \   00000140   0x7900             LDRB     R0,[R0, #+4]
   \   00000142   0x0007             MOVS     R7,R0
    277              i2c_Wait(i2cn);                                     //等待接收完成
   \   00000144   0x0028             MOVS     R0,R5
   \   00000146   0xB2C0             UXTB     R0,R0
   \   00000148   0x.... 0x....      BL       i2c_Wait
    278              i2c_Stop(i2cn);                                     //发送停止信号
   \   0000014C   0x....             LDR      R0,??DataTable4
   \   0000014E   0xB2ED             UXTB     R5,R5
   \   00000150   0x2104             MOVS     R1,#+4
   \   00000152   0x4369             MULS     R1,R5,R1
   \   00000154   0x5840             LDR      R0,[R0, R1]
   \   00000156   0x7881             LDRB     R1,[R0, #+2]
   \   00000158   0x20CF             MOVS     R0,#+207
   \   0000015A   0x4008             ANDS     R0,R0,R1
   \   0000015C   0x....             LDR      R1,??DataTable4
   \   0000015E   0xB2ED             UXTB     R5,R5
   \   00000160   0x2204             MOVS     R2,#+4
   \   00000162   0x436A             MULS     R2,R5,R2
   \   00000164   0x5889             LDR      R1,[R1, R2]
   \   00000166   0x7088             STRB     R0,[R1, #+2]
    279              *addr = I2CN[i2cn]->D;                              //读取数据
   \   00000168   0x....             LDR      R0,??DataTable4
   \   0000016A   0xB2ED             UXTB     R5,R5
   \   0000016C   0x2104             MOVS     R1,#+4
   \   0000016E   0x4369             MULS     R1,R5,R1
   \   00000170   0x5840             LDR      R0,[R0, R1]
   \   00000172   0x7900             LDRB     R0,[R0, #+4]
   \   00000174   0x7030             STRB     R0,[R6, #+0]
    280          
    281              i2c_delay();                                        //必须延时一下，否则出错
   \   00000176   0x.... 0x....      BL       i2c_delay
    282          
    283              return result;
   \   0000017A   0x0038             MOVS     R0,R7
   \   0000017C   0xB2C0             UXTB     R0,R0
   \   0000017E   0xBDFE             POP      {R1-R7,PC}       ;; return
    284          }
    285          
    286          //-------------------------------------------------------------------------------------------------------------------
    287          //  @brief      写入一个字节数据到I2C设备指定寄存器地址
    288          //  @param      i2cn        I2C模块(i2c0、i2c1)
    289          //  @param      SlaveID     从机地址(7位地址)
    290          //  @param      reg         从机寄存器地址
    291          //  @param      Data        数据
    292          //  @return     void
    293          //  @since      v2.0
    294          //  Sample usage:       	i2c_write_reg(i2c0, 0x2D, 0x50,2);     //写入数据2到0x50地址，从机地址为0x2D
    295          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    296          void i2c_write_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 Data)
    297          {
   \                     i2c_write_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    298          
    299              i2c_Start(i2cn);                                    //发送启动信号
   \   0000000A   0x....             LDR      R0,??DataTable4
   \   0000000C   0xB2E4             UXTB     R4,R4
   \   0000000E   0x2104             MOVS     R1,#+4
   \   00000010   0x4361             MULS     R1,R4,R1
   \   00000012   0x5840             LDR      R0,[R0, R1]
   \   00000014   0x7881             LDRB     R1,[R0, #+2]
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0x....             LDR      R1,??DataTable4
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0x4362             MULS     R2,R4,R2
   \   00000022   0x5889             LDR      R1,[R1, R2]
   \   00000024   0x7088             STRB     R0,[R1, #+2]
    300          
    301              i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
   \   00000026   0x0078             LSLS     R0,R7,#+1
   \   00000028   0x....             LDR      R1,??DataTable4
   \   0000002A   0xB2E4             UXTB     R4,R4
   \   0000002C   0x2204             MOVS     R2,#+4
   \   0000002E   0x4362             MULS     R2,R4,R2
   \   00000030   0x5889             LDR      R1,[R1, R2]
   \   00000032   0x7108             STRB     R0,[R1, #+4]
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x.... 0x....      BL       i2c_Wait
    302          
    303              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003C   0x....             LDR      R0,??DataTable4
   \   0000003E   0xB2E4             UXTB     R4,R4
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x4361             MULS     R1,R4,R1
   \   00000044   0x5840             LDR      R0,[R0, R1]
   \   00000046   0x7105             STRB     R5,[R0, #+4]
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB2C0             UXTB     R0,R0
   \   0000004C   0x.... 0x....      BL       i2c_Wait
    304          
    305              i2c_write_byte(i2cn, Data);                         //发送需要写入的数据
   \   00000050   0x....             LDR      R0,??DataTable4
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0x2104             MOVS     R1,#+4
   \   00000056   0x4361             MULS     R1,R4,R1
   \   00000058   0x5840             LDR      R0,[R0, R1]
   \   0000005A   0x7106             STRB     R6,[R0, #+4]
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xB2C0             UXTB     R0,R0
   \   00000060   0x.... 0x....      BL       i2c_Wait
    306          
    307              i2c_Stop(i2cn);
   \   00000064   0x....             LDR      R0,??DataTable4
   \   00000066   0xB2E4             UXTB     R4,R4
   \   00000068   0x2104             MOVS     R1,#+4
   \   0000006A   0x4361             MULS     R1,R4,R1
   \   0000006C   0x5840             LDR      R0,[R0, R1]
   \   0000006E   0x7881             LDRB     R1,[R0, #+2]
   \   00000070   0x20CF             MOVS     R0,#+207
   \   00000072   0x4008             ANDS     R0,R0,R1
   \   00000074   0x....             LDR      R1,??DataTable4
   \   00000076   0xB2E4             UXTB     R4,R4
   \   00000078   0x2204             MOVS     R2,#+4
   \   0000007A   0x4362             MULS     R2,R4,R2
   \   0000007C   0x5889             LDR      R1,[R1, R2]
   \   0000007E   0x7088             STRB     R0,[R1, #+2]
    308          
    309              i2c_delay();                                        //延时太短的话，可能写出错
   \   00000080   0x.... 0x....      BL       i2c_delay
    310          }
   \   00000084   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40048014         DC32     0x40048014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0xFFFEFFFF         DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0xFFFDFFFF         DC32     0xfffdffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     iic_error

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     iic_error_counter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     carStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x4004800C         DC32     0x4004800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40048010         DC32     0x40048010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0014 0x0016      DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
   \              0x0018 0x001A
   \              0x001C 0x001E
   \              0x0022 0x0028
   \              0x001C 0x0020
   \              0x0024 0x0028
   \              0x002C 0x0030
   \              0x0038 0x0044
   \              0x0030       
   \   00000022   0x0038 0x0040      DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
   \              0x0048 0x0050
   \              0x0058 0x0068
   \              0x0080 0x0050
   \              0x0060 0x0070
   \              0x0080 0x0090
   \              0x00A0 0x00C0
   \              0x00F0       
   \   00000040   0x00A0 0x00C0      DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
   \              0x00E0 0x0100
   \              0x0120 0x0140
   \              0x0180 0x01E0
   \              0x0140 0x0180
   \              0x01C0 0x0200
   \              0x0240       
   \   0000005A   0x0280 0x0300      DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
   \              0x03C0 0x0280
   \              0x0300 0x0380
   \              0x0400 0x0480
   \              0x0500 0x0600
   \              0x0780 0x0500
   \   00000072   0x0600 0x0700      DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840
   \              0x0800 0x0900
   \              0x0A00 0x0C00
   \              0x0F00       

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   i2c_Wait
        16   -> GpioSet
       8   i2c_delay
     160   i2c_init
       160   -> __aeabi_memcpy4
       160   -> abs
       160 __aeabi_uidiv
      24   i2c_read_reg
        24   -> i2c_Wait
        24   -> i2c_delay
      32   i2c_read_reg_bytes
        32   -> i2c_Wait
        32   -> i2c_delay
      24   i2c_write_reg
        24   -> i2c_Wait
        24   -> i2c_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       4  ??DataTable3
       4  ??DataTable4
     128  ?_0
       8  I2CN
       1  MasterTransmission
       1  SlaveID
     194  i2c_Wait
      26  i2c_delay
     294  i2c_init
     262  i2c_read_reg
     384  i2c_read_reg_bytes
     134  i2c_write_reg

 
     2 bytes in section .bss
     8 bytes in section .data
   128 bytes in section .rodata
 1 346 bytes in section .text
 
 1 346 bytes of CODE  memory
   128 bytes of CONST memory
    10 bytes of DATA  memory

Errors: none
Warnings: none
