###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        17/Jul/2018  09:40:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  H:\智能车程序2018\电磁三轮――ZS\7.17\user\C\inductor_1.c
#    Command line =  
#        H:\智能车程序2018\电磁三轮――ZS\7.17\user\C\inductor_1.c -D IAR -D
#        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -lCN
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\KEA_128_RAM\List\ -lB
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\KEA_128_RAM\List\ -o
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\KEA_128_RAM\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None
#        --dlib_config H:\IAR7.3\arm\INC\c\DLib_Config_Normal.h -I
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\..\device\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\..\user\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\..\system\ -I
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\..\lib\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\..\system\coreSupport\ -Ol
#    List file    =  
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\KEA_128_RAM\List\inductor_1.lst
#    Object file  =  
#        H:\智能车程序2018\电磁三轮――ZS\7.17\iar\KEA_128_RAM\Obj\inductor_1.o
#
###############################################################################

H:\智能车程序2018\电磁三轮――ZS\7.17\user\C\inductor_1.c
      1          #include "inductor_1.h"
      2          #include "Variable.h"
      3          #include "common.h"
      4          #include "allHead.h"
      5          
      6          
      7          
      8          //右  中 左   右竖 左竖 gnd
      9          //橙  红 褐    黑   白  黄
     10          //橙  黄 蓝    灰   紫  绿色
     11          //4   2  3    1    5
     12          //1   2  3    4     5
     13          //              右电感   中电感   左电感   位置     差值
     14          //右电感最大    490,97    250,50  16,1      1        -95
     15          //左电感最大    4,0.1    240,47  509,100    2         99
     16          //过左弯道时     40,7    312,62   287,57    2          50      
     17          //过左弯道时     4，0.1    194,38   287,57    2          50    
     18                                               //          范围
     19          //AD值：AD_valu[3]为采集到处理后的的AD值          0-260(小车行驶时)
     20          //归一值sensor_to_one[5]为将AD值归一化            0-1
     21          //最终值：AD_inductor[5]为将归一化的值放大100倍    0-100
     22          //丢线：信号很小了，然后就按照找不到信号线来处理
     23          //Position_transit[i]:记录过渡点归一化放大后的值
     24          //Position_transit[0]:右电感位于电磁线正上方时中电感归一化放大后的值
     25          //Position_transit[1]:左电感位于电磁线正上方时中电感归一化放大后的值
     26          //差值：差值大小由中电感与电磁线的相对位置决定
     27          //小车在赛道内差值为100以内，出半个赛道200左右，全出赛道300左右
     28          
     29          
     30          
     31          
     32          
     33          
     34          /*************************************************************************
     35           *  函数名称   Read_ADC
     36           *  功能说明： AD采集
     37           *  参数说明：
     38           *  函数返回： 无
     39           *  修改时间：
     40           *  备    注：
     41          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     42          void Read_ADC(void)
     43          {
   \                     Read_ADC: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
     44                int16  i,j,k,temp;
     45                int16  ad_valu1[5],ad_sum[5];
     46          
     47                for(i=0;i<5;i++)
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE031             B        ??Read_ADC_0
     48                {
     49          
     50          //            ad_valu[0][i] = ADC_Once(ADC_1,adc12bit);  //左  通道
     51          //            ad_valu[1][i] = ADC_Once(ADC_2,adc12bit);  //中  通道
     52          //            ad_valu[2][i] = ADC_Once(ADC_3,adc12bit);  //右  通道
     53          //            ad_valu[3][i] = ADC_Once(ADC_4,adc12bit);  //中1 通道
     54          //            ad_valu[4][i] = ADC_Once(ADC_5,adc12bit);  //中2 通道
     55                  
     56                           ad_valu[0][i] = ADC_Once(ADC_5,adc12bit);  //左  通道
   \                     ??Read_ADC_1: (+1)
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x202C             MOVS     R0,#+44
   \   0000000C   0x.... 0x....      BL       ADC_Once
   \   00000010   0x....             LDR      R1,??DataTable1
   \   00000012   0xB224             SXTH     R4,R4
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0x4362             MULS     R2,R4,R2
   \   00000018   0x5288             STRH     R0,[R1, R2]
     57                      ad_valu[1][i] = ADC_Once(ADC_4,adc12bit);  //中  通道
   \   0000001A   0x2102             MOVS     R1,#+2
   \   0000001C   0x202D             MOVS     R0,#+45
   \   0000001E   0x.... 0x....      BL       ADC_Once
   \   00000022   0x....             LDR      R1,??DataTable1
   \   00000024   0xB224             SXTH     R4,R4
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x4362             MULS     R2,R4,R2
   \   0000002A   0x1889             ADDS     R1,R1,R2
   \   0000002C   0x8148             STRH     R0,[R1, #+10]
     58                      ad_valu[2][i] = ADC_Once(ADC_3,adc12bit);  //右  通道
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x202F             MOVS     R0,#+47
   \   00000032   0x.... 0x....      BL       ADC_Once
   \   00000036   0x....             LDR      R1,??DataTable1
   \   00000038   0xB224             SXTH     R4,R4
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x4362             MULS     R2,R4,R2
   \   0000003E   0x1889             ADDS     R1,R1,R2
   \   00000040   0x8288             STRH     R0,[R1, #+20]
     59                      ad_valu[3][i] = ADC_Once(ADC_2,adc12bit);  //中1 通道
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0x2011             MOVS     R0,#+17
   \   00000046   0x.... 0x....      BL       ADC_Once
   \   0000004A   0x....             LDR      R1,??DataTable1
   \   0000004C   0xB224             SXTH     R4,R4
   \   0000004E   0x2202             MOVS     R2,#+2
   \   00000050   0x4362             MULS     R2,R4,R2
   \   00000052   0x1889             ADDS     R1,R1,R2
   \   00000054   0x83C8             STRH     R0,[R1, #+30]
     60                      ad_valu[4][i] = ADC_Once(ADC_1,adc12bit);  //中2 通道
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0x.... 0x....      BL       ADC_Once
   \   0000005E   0x....             LDR      R1,??DataTable1
   \   00000060   0xB224             SXTH     R4,R4
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0x4362             MULS     R2,R4,R2
   \   00000066   0x1889             ADDS     R1,R1,R2
   \   00000068   0x8508             STRH     R0,[R1, #+40]
     61                      
     62          //            if(ad_valu[0][i] > 650) ad_valu[0][i]=500;
     63          //            if(ad_valu[1][i] > 650) ad_valu[0][i]=500;
     64          //            if(ad_valu[2][i] > 650) ad_valu[0][i]=500;
     65          
     66                }
   \   0000006A   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_0: (+1)
   \   0000006C   0xB224             SXTH     R4,R4
   \   0000006E   0x2C05             CMP      R4,#+5
   \   00000070   0xDBCA             BLT      ??Read_ADC_1
     67             //////////////////////冒泡排序///////////////////////////////////
     68                for(i=0;i<5;i++)     //5个电感
   \   00000072   0x2400             MOVS     R4,#+0
   \   00000074   0xE000             B        ??Read_ADC_2
   \                     ??Read_ADC_3: (+1)
   \   00000076   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_2: (+1)
   \   00000078   0xB224             SXTH     R4,R4
   \   0000007A   0x2C05             CMP      R4,#+5
   \   0000007C   0xDA4B             BGE      ??Read_ADC_4
     69                {
     70                   for(j=0;j<4;j++)  //五个数据排序
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE044             B        ??Read_ADC_5
     71                   {
     72                      for(k=0;k<4-j;k++)
     73                      {
     74                         if(ad_valu[i][k] > ad_valu[i][k+1])  //前面的比后面的大  则进行交换
   \                     ??Read_ADC_6: (+1)
   \   00000082   0x....             LDR      R2,??DataTable1
   \   00000084   0xB224             SXTH     R4,R4
   \   00000086   0x230A             MOVS     R3,#+10
   \   00000088   0x4363             MULS     R3,R4,R3
   \   0000008A   0x18D2             ADDS     R2,R2,R3
   \   0000008C   0xB209             SXTH     R1,R1
   \   0000008E   0x2302             MOVS     R3,#+2
   \   00000090   0x434B             MULS     R3,R1,R3
   \   00000092   0x18D2             ADDS     R2,R2,R3
   \   00000094   0x2302             MOVS     R3,#+2
   \   00000096   0x5ED2             LDRSH    R2,[R2, R3]
   \   00000098   0x....             LDR      R3,??DataTable1
   \   0000009A   0xB224             SXTH     R4,R4
   \   0000009C   0x250A             MOVS     R5,#+10
   \   0000009E   0x4365             MULS     R5,R4,R5
   \   000000A0   0x195B             ADDS     R3,R3,R5
   \   000000A2   0xB209             SXTH     R1,R1
   \   000000A4   0x2502             MOVS     R5,#+2
   \   000000A6   0x434D             MULS     R5,R1,R5
   \   000000A8   0x5F5B             LDRSH    R3,[R3, R5]
   \   000000AA   0x429A             CMP      R2,R3
   \   000000AC   0xDA26             BGE      ??Read_ADC_7
     75                         {
     76                            temp = ad_valu[i][k+1];
   \   000000AE   0x....             LDR      R2,??DataTable1
   \   000000B0   0xB224             SXTH     R4,R4
   \   000000B2   0x230A             MOVS     R3,#+10
   \   000000B4   0x4363             MULS     R3,R4,R3
   \   000000B6   0x18D2             ADDS     R2,R2,R3
   \   000000B8   0xB209             SXTH     R1,R1
   \   000000BA   0x2302             MOVS     R3,#+2
   \   000000BC   0x434B             MULS     R3,R1,R3
   \   000000BE   0x18D2             ADDS     R2,R2,R3
   \   000000C0   0x2302             MOVS     R3,#+2
   \   000000C2   0x5ED2             LDRSH    R2,[R2, R3]
     77                            ad_valu[i][k+1] = ad_valu[i][k];
   \   000000C4   0x....             LDR      R3,??DataTable1
   \   000000C6   0xB224             SXTH     R4,R4
   \   000000C8   0x250A             MOVS     R5,#+10
   \   000000CA   0x4365             MULS     R5,R4,R5
   \   000000CC   0x195B             ADDS     R3,R3,R5
   \   000000CE   0xB209             SXTH     R1,R1
   \   000000D0   0x2502             MOVS     R5,#+2
   \   000000D2   0x434D             MULS     R5,R1,R5
   \   000000D4   0x195B             ADDS     R3,R3,R5
   \   000000D6   0x....             LDR      R5,??DataTable1
   \   000000D8   0xB224             SXTH     R4,R4
   \   000000DA   0x260A             MOVS     R6,#+10
   \   000000DC   0x4366             MULS     R6,R4,R6
   \   000000DE   0x19AD             ADDS     R5,R5,R6
   \   000000E0   0xB209             SXTH     R1,R1
   \   000000E2   0x2602             MOVS     R6,#+2
   \   000000E4   0x434E             MULS     R6,R1,R6
   \   000000E6   0x5BAD             LDRH     R5,[R5, R6]
   \   000000E8   0x805D             STRH     R5,[R3, #+2]
     78                            ad_valu[i][k] = temp;
   \   000000EA   0x....             LDR      R3,??DataTable1
   \   000000EC   0xB224             SXTH     R4,R4
   \   000000EE   0x250A             MOVS     R5,#+10
   \   000000F0   0x4365             MULS     R5,R4,R5
   \   000000F2   0x195B             ADDS     R3,R3,R5
   \   000000F4   0xB209             SXTH     R1,R1
   \   000000F6   0x2502             MOVS     R5,#+2
   \   000000F8   0x434D             MULS     R5,R1,R5
   \   000000FA   0x535A             STRH     R2,[R3, R5]
     79                         }
     80                      }
   \                     ??Read_ADC_7: (+1)
   \   000000FC   0x1C49             ADDS     R1,R1,#+1
   \                     ??Read_ADC_8: (+1)
   \   000000FE   0xB209             SXTH     R1,R1
   \   00000100   0x2204             MOVS     R2,#+4
   \   00000102   0xB200             SXTH     R0,R0
   \   00000104   0x1A12             SUBS     R2,R2,R0
   \   00000106   0x4291             CMP      R1,R2
   \   00000108   0xDBBB             BLT      ??Read_ADC_6
   \   0000010A   0x1C40             ADDS     R0,R0,#+1
   \                     ??Read_ADC_5: (+1)
   \   0000010C   0xB200             SXTH     R0,R0
   \   0000010E   0x2804             CMP      R0,#+4
   \   00000110   0xDAB1             BGE      ??Read_ADC_3
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0xE7F3             B        ??Read_ADC_8
     81                   }
     82                }
     83                for(i=0;i<5;i++)    //求中间三项的和
   \                     ??Read_ADC_4: (+1)
   \   00000116   0x2400             MOVS     R4,#+0
   \   00000118   0xE026             B        ??Read_ADC_9
     84                {
     85                   ad_sum[i] = ad_valu[i][1] + ad_valu[i][2] + ad_valu[i][3];
   \                     ??Read_ADC_10: (+1)
   \   0000011A   0x....             LDR      R0,??DataTable1
   \   0000011C   0xB224             SXTH     R4,R4
   \   0000011E   0x210A             MOVS     R1,#+10
   \   00000120   0x4361             MULS     R1,R4,R1
   \   00000122   0x1840             ADDS     R0,R0,R1
   \   00000124   0x8840             LDRH     R0,[R0, #+2]
   \   00000126   0x....             LDR      R1,??DataTable1
   \   00000128   0xB224             SXTH     R4,R4
   \   0000012A   0x220A             MOVS     R2,#+10
   \   0000012C   0x4362             MULS     R2,R4,R2
   \   0000012E   0x1889             ADDS     R1,R1,R2
   \   00000130   0x8889             LDRH     R1,[R1, #+4]
   \   00000132   0x1840             ADDS     R0,R0,R1
   \   00000134   0x....             LDR      R1,??DataTable1
   \   00000136   0xB224             SXTH     R4,R4
   \   00000138   0x220A             MOVS     R2,#+10
   \   0000013A   0x4362             MULS     R2,R4,R2
   \   0000013C   0x1889             ADDS     R1,R1,R2
   \   0000013E   0x88C9             LDRH     R1,[R1, #+6]
   \   00000140   0x1840             ADDS     R0,R0,R1
   \   00000142   0x4669             MOV      R1,SP
   \   00000144   0xB224             SXTH     R4,R4
   \   00000146   0x2202             MOVS     R2,#+2
   \   00000148   0x4362             MULS     R2,R4,R2
   \   0000014A   0x5288             STRH     R0,[R1, R2]
     86                   ad_valu1[i] = ad_sum[i] / 3;
   \   0000014C   0x4668             MOV      R0,SP
   \   0000014E   0xB224             SXTH     R4,R4
   \   00000150   0x2102             MOVS     R1,#+2
   \   00000152   0x4361             MULS     R1,R4,R1
   \   00000154   0x5E40             LDRSH    R0,[R0, R1]
   \   00000156   0x2103             MOVS     R1,#+3
   \   00000158   0x.... 0x....      BL       __aeabi_idiv
   \   0000015C   0xA903             ADD      R1,SP,#+12
   \   0000015E   0xB224             SXTH     R4,R4
   \   00000160   0x2202             MOVS     R2,#+2
   \   00000162   0x4362             MULS     R2,R4,R2
   \   00000164   0x5288             STRH     R0,[R1, R2]
     87                }
   \   00000166   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_9: (+1)
   \   00000168   0xB224             SXTH     R4,R4
   \   0000016A   0x2C05             CMP      R4,#+5
   \   0000016C   0xDBD5             BLT      ??Read_ADC_10
     88             ////////////////////////滑动平均滤波/////////////////////////////
     89                for(i = 0;i < NM-1;i ++)  //取中间3位的值到前三位
   \   0000016E   0x2400             MOVS     R4,#+0
   \   00000170   0xE040             B        ??Read_ADC_11
     90                {
     91                    AD_V[0][i] = ad_valu[0][i + 1];
   \                     ??Read_ADC_12: (+1)
   \   00000172   0x....             LDR      R0,??DataTable1
   \   00000174   0xB224             SXTH     R4,R4
   \   00000176   0x2102             MOVS     R1,#+2
   \   00000178   0x4361             MULS     R1,R4,R1
   \   0000017A   0x1840             ADDS     R0,R0,R1
   \   0000017C   0x2102             MOVS     R1,#+2
   \   0000017E   0x5E40             LDRSH    R0,[R0, R1]
   \   00000180   0x....             LDR      R1,??DataTable1_1
   \   00000182   0xB224             SXTH     R4,R4
   \   00000184   0x2204             MOVS     R2,#+4
   \   00000186   0x4362             MULS     R2,R4,R2
   \   00000188   0x5088             STR      R0,[R1, R2]
     92                    AD_V[1][i] = ad_valu[1][i + 1];
   \   0000018A   0x....             LDR      R0,??DataTable1
   \   0000018C   0xB224             SXTH     R4,R4
   \   0000018E   0x2102             MOVS     R1,#+2
   \   00000190   0x4361             MULS     R1,R4,R1
   \   00000192   0x1840             ADDS     R0,R0,R1
   \   00000194   0x210C             MOVS     R1,#+12
   \   00000196   0x5E40             LDRSH    R0,[R0, R1]
   \   00000198   0x....             LDR      R1,??DataTable1_1
   \   0000019A   0xB224             SXTH     R4,R4
   \   0000019C   0x2204             MOVS     R2,#+4
   \   0000019E   0x4362             MULS     R2,R4,R2
   \   000001A0   0x1889             ADDS     R1,R1,R2
   \   000001A2   0x60C8             STR      R0,[R1, #+12]
     93                    AD_V[2][i] = ad_valu[2][i + 1];
   \   000001A4   0x....             LDR      R0,??DataTable1
   \   000001A6   0xB224             SXTH     R4,R4
   \   000001A8   0x2102             MOVS     R1,#+2
   \   000001AA   0x4361             MULS     R1,R4,R1
   \   000001AC   0x1840             ADDS     R0,R0,R1
   \   000001AE   0x2116             MOVS     R1,#+22
   \   000001B0   0x5E40             LDRSH    R0,[R0, R1]
   \   000001B2   0x....             LDR      R1,??DataTable1_1
   \   000001B4   0xB224             SXTH     R4,R4
   \   000001B6   0x2204             MOVS     R2,#+4
   \   000001B8   0x4362             MULS     R2,R4,R2
   \   000001BA   0x1889             ADDS     R1,R1,R2
   \   000001BC   0x6188             STR      R0,[R1, #+24]
     94                    AD_V[3][i] = ad_valu[3][i + 1];
   \   000001BE   0x....             LDR      R0,??DataTable1
   \   000001C0   0xB224             SXTH     R4,R4
   \   000001C2   0x2102             MOVS     R1,#+2
   \   000001C4   0x4361             MULS     R1,R4,R1
   \   000001C6   0x1840             ADDS     R0,R0,R1
   \   000001C8   0x2120             MOVS     R1,#+32
   \   000001CA   0x5E40             LDRSH    R0,[R0, R1]
   \   000001CC   0x....             LDR      R1,??DataTable1_1
   \   000001CE   0xB224             SXTH     R4,R4
   \   000001D0   0x2204             MOVS     R2,#+4
   \   000001D2   0x4362             MULS     R2,R4,R2
   \   000001D4   0x1889             ADDS     R1,R1,R2
   \   000001D6   0x6248             STR      R0,[R1, #+36]
     95                    AD_V[4][i] = ad_valu[4][i + 1];
   \   000001D8   0x....             LDR      R0,??DataTable1
   \   000001DA   0xB224             SXTH     R4,R4
   \   000001DC   0x2102             MOVS     R1,#+2
   \   000001DE   0x4361             MULS     R1,R4,R1
   \   000001E0   0x1840             ADDS     R0,R0,R1
   \   000001E2   0x212A             MOVS     R1,#+42
   \   000001E4   0x5E40             LDRSH    R0,[R0, R1]
   \   000001E6   0x....             LDR      R1,??DataTable1_1
   \   000001E8   0xB224             SXTH     R4,R4
   \   000001EA   0x2204             MOVS     R2,#+4
   \   000001EC   0x4362             MULS     R2,R4,R2
   \   000001EE   0x1889             ADDS     R1,R1,R2
   \   000001F0   0x6308             STR      R0,[R1, #+48]
     96                }
   \   000001F2   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_11: (+1)
   \   000001F4   0xB224             SXTH     R4,R4
   \   000001F6   0x2C02             CMP      R4,#+2
   \   000001F8   0xDBBB             BLT      ??Read_ADC_12
     97                for(i=0;i<5;i++)   //第三位存储平均值
   \   000001FA   0x2400             MOVS     R4,#+0
   \   000001FC   0xE00B             B        ??Read_ADC_13
     98                {
     99                    AD_V[i][NM-1] =  ad_valu1[i];
   \                     ??Read_ADC_14: (+1)
   \   000001FE   0xA803             ADD      R0,SP,#+12
   \   00000200   0xB224             SXTH     R4,R4
   \   00000202   0x2102             MOVS     R1,#+2
   \   00000204   0x4361             MULS     R1,R4,R1
   \   00000206   0x5E40             LDRSH    R0,[R0, R1]
   \   00000208   0x....             LDR      R1,??DataTable1_1
   \   0000020A   0xB224             SXTH     R4,R4
   \   0000020C   0x220C             MOVS     R2,#+12
   \   0000020E   0x4362             MULS     R2,R4,R2
   \   00000210   0x1889             ADDS     R1,R1,R2
   \   00000212   0x6088             STR      R0,[R1, #+8]
    100                }
   \   00000214   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_13: (+1)
   \   00000216   0xB224             SXTH     R4,R4
   \   00000218   0x2C05             CMP      R4,#+5
   \   0000021A   0xDBF0             BLT      ??Read_ADC_14
    101                   for(i = 0;i < NM;i ++)   //得到原中间三位的值
   \   0000021C   0x2400             MOVS     R4,#+0
   \   0000021E   0xE036             B        ??Read_ADC_15
    102                {
    103                    AD_sum[0] += AD_V[0][i];
   \                     ??Read_ADC_16: (+1)
   \   00000220   0x....             LDR      R0,??DataTable1_2
   \   00000222   0x6800             LDR      R0,[R0, #+0]
   \   00000224   0x....             LDR      R1,??DataTable1_1
   \   00000226   0xB224             SXTH     R4,R4
   \   00000228   0x2204             MOVS     R2,#+4
   \   0000022A   0x4362             MULS     R2,R4,R2
   \   0000022C   0x5889             LDR      R1,[R1, R2]
   \   0000022E   0x1840             ADDS     R0,R0,R1
   \   00000230   0x....             LDR      R1,??DataTable1_2
   \   00000232   0x6008             STR      R0,[R1, #+0]
    104                    AD_sum[1] += AD_V[1][i];
   \   00000234   0x....             LDR      R0,??DataTable1_2
   \   00000236   0x6840             LDR      R0,[R0, #+4]
   \   00000238   0x....             LDR      R1,??DataTable1_1
   \   0000023A   0xB224             SXTH     R4,R4
   \   0000023C   0x2204             MOVS     R2,#+4
   \   0000023E   0x4362             MULS     R2,R4,R2
   \   00000240   0x1889             ADDS     R1,R1,R2
   \   00000242   0x68C9             LDR      R1,[R1, #+12]
   \   00000244   0x1840             ADDS     R0,R0,R1
   \   00000246   0x....             LDR      R1,??DataTable1_2
   \   00000248   0x6048             STR      R0,[R1, #+4]
    105                    AD_sum[2] += AD_V[2][i];
   \   0000024A   0x....             LDR      R0,??DataTable1_2
   \   0000024C   0x6880             LDR      R0,[R0, #+8]
   \   0000024E   0x....             LDR      R1,??DataTable1_1
   \   00000250   0xB224             SXTH     R4,R4
   \   00000252   0x2204             MOVS     R2,#+4
   \   00000254   0x4362             MULS     R2,R4,R2
   \   00000256   0x1889             ADDS     R1,R1,R2
   \   00000258   0x6989             LDR      R1,[R1, #+24]
   \   0000025A   0x1840             ADDS     R0,R0,R1
   \   0000025C   0x....             LDR      R1,??DataTable1_2
   \   0000025E   0x6088             STR      R0,[R1, #+8]
    106                    AD_sum[3] += AD_V[3][i];
   \   00000260   0x....             LDR      R0,??DataTable1_2
   \   00000262   0x68C0             LDR      R0,[R0, #+12]
   \   00000264   0x....             LDR      R1,??DataTable1_1
   \   00000266   0xB224             SXTH     R4,R4
   \   00000268   0x2204             MOVS     R2,#+4
   \   0000026A   0x4362             MULS     R2,R4,R2
   \   0000026C   0x1889             ADDS     R1,R1,R2
   \   0000026E   0x6A49             LDR      R1,[R1, #+36]
   \   00000270   0x1840             ADDS     R0,R0,R1
   \   00000272   0x....             LDR      R1,??DataTable1_2
   \   00000274   0x60C8             STR      R0,[R1, #+12]
    107                    AD_sum[4] += AD_V[4][i];
   \   00000276   0x....             LDR      R0,??DataTable1_2
   \   00000278   0x6900             LDR      R0,[R0, #+16]
   \   0000027A   0x....             LDR      R1,??DataTable1_1
   \   0000027C   0xB224             SXTH     R4,R4
   \   0000027E   0x2204             MOVS     R2,#+4
   \   00000280   0x4362             MULS     R2,R4,R2
   \   00000282   0x1889             ADDS     R1,R1,R2
   \   00000284   0x6B09             LDR      R1,[R1, #+48]
   \   00000286   0x1840             ADDS     R0,R0,R1
   \   00000288   0x....             LDR      R1,??DataTable1_2
   \   0000028A   0x6108             STR      R0,[R1, #+16]
    108                }
   \   0000028C   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_15: (+1)
   \   0000028E   0xB224             SXTH     R4,R4
   \   00000290   0x2C03             CMP      R4,#+3
   \   00000292   0xDBC5             BLT      ??Read_ADC_16
    109                for(i=0;i<5;i++)  //求平均
   \   00000294   0x2400             MOVS     R4,#+0
   \   00000296   0xE013             B        ??Read_ADC_17
    110                {
    111                    AD_valu[i] = AD_sum[i] / NM;
   \                     ??Read_ADC_18: (+1)
   \   00000298   0x....             LDR      R0,??DataTable1_2
   \   0000029A   0xB224             SXTH     R4,R4
   \   0000029C   0x2104             MOVS     R1,#+4
   \   0000029E   0x4361             MULS     R1,R4,R1
   \   000002A0   0x5840             LDR      R0,[R0, R1]
   \   000002A2   0x2103             MOVS     R1,#+3
   \   000002A4   0x.... 0x....      BL       __aeabi_idiv
   \   000002A8   0x....             LDR      R1,??DataTable1_3
   \   000002AA   0xB224             SXTH     R4,R4
   \   000002AC   0x2204             MOVS     R2,#+4
   \   000002AE   0x4362             MULS     R2,R4,R2
   \   000002B0   0x5088             STR      R0,[R1, R2]
    112                    AD_sum[i] = 0;
   \   000002B2   0x2000             MOVS     R0,#+0
   \   000002B4   0x....             LDR      R1,??DataTable1_2
   \   000002B6   0xB224             SXTH     R4,R4
   \   000002B8   0x2204             MOVS     R2,#+4
   \   000002BA   0x4362             MULS     R2,R4,R2
   \   000002BC   0x5088             STR      R0,[R1, R2]
    113                }
   \   000002BE   0x1C64             ADDS     R4,R4,#+1
   \                     ??Read_ADC_17: (+1)
   \   000002C0   0xB224             SXTH     R4,R4
   \   000002C2   0x2C05             CMP      R4,#+5
   \   000002C4   0xDBE8             BLT      ??Read_ADC_18
    114          }
   \   000002C6   0xB006             ADD      SP,SP,#+24
   \   000002C8   0xBD70             POP      {R4-R6,PC}       ;; return
    115          
    116          
    117          
    118          
    119          
    120          
    121          
    122          
    123          
    124          
    125          ///*************************************************************************
    126          // *  函数名称   Date_analyse
    127          // *  功能说明： 数据分析
    128          // *  参数说明：
    129          // *  函数返回： 无
    130          // *  修改时间：
    131          // *  备    注：
    132          //*************************************************************************/
    133          //void Date_analyse()
    134          //{
    135          ////     char Chazhi_flag = 0;
    136          ////     char Chazhi_value[11];
    137          ////     int16  a,b;
    138          //     int16  i,max_front=0,max_back;
    139          //     static int16 max_old = 1,max_crosstalk = 1;
    140          //     static int16 position_last = 2;
    141          //     float  sensor_1;
    142          //
    143          //     Read_ADC();
    144          //
    145          //    Inductor_Check();//电感最大最小值校验 
    146          //     /*********************归一化处理********************/
    147          //     for(i=0;i<5;i++)
    148          //     {
    149          //        sensor_to_one[i] = (float)(AD_valu[i] - min_v[i])/(float)(max_v[i]- min_v[i]);
    150          //      if(sensor_to_one[i]<=0.0)  sensor_to_one[i]=0.001;
    151          ////        if(sensor_to_one[0]<=0.0)  sensor_to_one[0]=0.001;
    152          ////        if(sensor_to_one[0]>1.0)  sensor_to_one[0]=1.0;
    153          ////        
    154          ////        if(sensor_to_one[2]<=0.0)  sensor_to_one[2]=0.001;
    155          ////        if(sensor_to_one[2]>1.0)  sensor_to_one[2]=1.0;
    156          //
    157          //        AD_inductor[i] = 100 * sensor_to_one[i];     //AD[i]为归一化后的值  范围为0-100
    158          //     }
    159          //       /*******1号电感特殊归一化，用于坡道检测********/
    160          //      sensor_1 = (float)(AD_valu[1] - min_v[1])/(float)(ad_valu[1][0] - min_v[1]);
    161          //      if(sensor_1 <= 0.0)  sensor_1 = 0.001;
    162          //      Slope_AD_1 = 100 * sensor_1;
    163          //   ////////////////////////////////////////////////////////////////////
    164          //
    165          //       for(i=0;i<3;i++)                 //找出最强的传感器
    166          //       {
    167          //         if(AD_inductor[max_front]<AD_inductor[i])
    168          //           max_front=i;
    169          //       }
    170          //       max_value=AD_inductor[max_front];  //最大电感值
    171          //
    172          //    //   max_back = (AD_inductor[3]>AD_inductor[4])? 3:4;  //找后排最强电感
    173          // //zs屏蔽      
    174          //       //丢线时最大值取旧值
    175          //       if(max_value < 5)           
    176          //       {
    177          //         max_front=max_old;
    178          //         max_value=AD_inductor[max_front];
    179          //       }
    180          //       else
    181          //         max_old=max_front;
    182          ////       //防串道
    183          //       if(abs_inductor(max_front - max_crosstalk) < 2)  
    184          //       {
    185          //            max_crosstalk = max_front;
    186          //       }
    187          //       else
    188          //            max_front = max_crosstalk;
    189          // //张盛屏蔽      
    190          //      // AD_MAX_NUM = max_front;        //传送速度控制
    191          //       
    192          //        /****************位置解算，解算过程的值用归一化放大后的值************************/
    193          ////zs1    
    194          //       
    195          ////       if((max_front==0&&AD_inductor[1] > 5)||(max_front==1 && (AD_inductor[0] > AD_inductor[2])  ))
    196          ////       {
    197          ////           position=1;         
    198          ////       }
    199          ////       if((max_front==0&&AD_inductor[1] > 5)||(max_front==1 && (AD_inductor[0] < AD_inductor[2])  ))
    200          ////       {
    201          ////           position=2;         
    202          ////       }
    203          ////         
    204          ////         
    205          ////ZS2       
    206          //        if(max_front==0 && (AD_inductor[1] <= Position_transit[0] ))  //已经偏离0号传感器
    207          //       {//右电感最大且此时的中电感值<=过渡点0时中电感的值
    208          //             position=0;//右电感在电磁线左方，整个小车都在电磁线左方
    209          // //          AD_0_max = AD_inductor[0];//zs加
    210          //       }
    211          //       else if((max_front==0 && (AD_inductor[1] > Position_transit[0] )) || (max_front==1 && (AD_inductor[0] >AD_inductor[2]) ))  //左侧位置  0-1号传感器之间
    212          //       {//右电感最大且此时中电感的值>过渡点0时中电感的值||中电感最大且右电感的值>左电感的值
    213          //           //      中电感在电磁线左边                            中电感在电磁线左边
    214          //             position=1;//中电感在电磁线左边,小车偏左(半个小车以上部分在电磁线左边但不是全部)
    215          //             AD_0_max = AD_inductor[0]; //记录下此时的0号传感器的归一放大后的值
    216          //       }
    217          //       else if((max_front==1 && (AD_inductor[2] >AD_inductor[0]) ) || (max_front==2 && (AD_inductor[1] > Position_transit[1] )))  //右侧位置  1-2号传感器之间
    218          //       {//中电感最大且左电感的值大于右电感的值||左电感最大且此时中电感的值>过渡点1时中电感的值
    219          //        //    中电感在电磁线右边                         中电感在电磁线右边          
    220          //             position=2;//中电感在电磁线右边,小车偏右(半个小车以上部分在电磁线右边但不是全部)
    221          //             AD_2_max = AD_inductor[2]; //记录下此时的3号传感器归一放大后的值
    222          //       }
    223          //       else if(max_front==2 && (AD_inductor[1] <= Position_transit[1] ))  //已经偏离3号传感器
    224          //       {//左电感最大且此时的中电感值<=过渡点1时中电感的值
    225          //             position = 3;//左电感在电磁线右方，整个小车都在电磁线右方
    226          //        // AD_2_max = AD_inductor[2];//zs加
    227          //
    228          //       }   
    229          //         
    230          //         
    231          ////Position_transit[0]:右电感位于电磁线正上方时中电感归一化放大后的值
    232          ////Position_transit[1]:左电感位于电磁线正上方时中电感归一化放大后的值中电感的值
    233          ////       if(max_front==0 && (AD_inductor[1] <= Position_transit[0] ))  //已经偏离0号传感器
    234          ////       {//右电感最大且此时的中电感值<=过渡点0时中电感的值
    235          ////             position=0;//右电感在电磁线左方，整个小车都在电磁线左方
    236          //// //          AD_0_max = AD_inductor[0];//zs加
    237          ////       }
    238          ////       else if((max_front==0 && (AD_inductor[1] > Position_transit[0] + 1)) || (max_front==1 && (AD_inductor[0] - AD_inductor[2]) > 1))  //左侧位置  0-1号传感器之间
    239          ////       {//右电感最大且此时中电感的值>过渡点0时中电感的值||中电感最大且右电感的值>左电感的值
    240          ////           //      中电感在电磁线左边                            中电感在电磁线左边
    241          ////             position=1;//中电感在电磁线左边,小车偏左(半个小车以上部分在电磁线左边但不是全部)
    242          ////             AD_0_max = AD_inductor[0]; //记录下此时的0号传感器的归一放大后的值
    243          ////       }
    244          ////       else if((max_front==1 && (AD_inductor[2] - AD_inductor[0]) > 1) || (max_front==2 && (AD_inductor[1] > Position_transit[1] + 1)))  //右侧位置  1-2号传感器之间
    245          ////       {//中电感最大且左电感的值大于右电感的值||左电感最大且此时中电感的值>过渡点1时中电感的值
    246          ////        //    中电感在电磁线右边                         中电感在电磁线右边          
    247          ////             position=2;//中电感在电磁线右边,小车偏右(半个小车以上部分在电磁线右边但不是全部)
    248          ////             AD_2_max = AD_inductor[2]; //记录下此时的3号传感器归一放大后的值
    249          ////       }
    250          ////       else if(max_front==2 && (AD_inductor[1] <= Position_transit[1] - 1))  //已经偏离3号传感器
    251          ////       {//左电感最大且此时的中电感值<=过渡点1时中电感的值
    252          ////             position = 3;//左电感在电磁线右方，整个小车都在电磁线右方
    253          ////        // AD_2_max = AD_inductor[2];//zs加
    254          ////
    255          ////       }
    256          //       /*
    257          //       //~~~~~~~~~~~~~~~~~~~~~~~ 后排位置解算~~~~~~~~~~~~~~~~~~~//
    258          //       if(max_back == 3 && AD_inductor[4] <= Position_transit[2] - 1)
    259          //       {
    260          //            if(AD_inductor[4] <= Position_transit[2] - 22)
    261          //               position_back = 0;
    262          //            if(AD_inductor[4] >= Position_transit[2] - 20)
    263          //               position_back = 1;
    264          //       }
    265          //       else  if(max_back == 3 && AD_inductor[4] > Position_transit[2] + 1 || max_back == 4 && AD_inductor[3] > Position_transit[3] + 1)
    266          //       {
    267          //            position_back = 2;
    268          //       }
    269          //       else if(max_back == 4 && AD_inductor[3] <= Position_transit[3] - 1)
    270          //       {
    271          //            if(AD_inductor[3] >= Position_transit[3] - 20)
    272          //               position_back = 3;
    273          //            if(AD_inductor[3] <= Position_transit[3] - 22)
    274          //               position_back = 4;
    275          //       }
    276          //       */
    277          //      /*位置防跳变过大，比如前1ms小车都在电磁线左边，后1ms小车偏右*/  
    278          // //zs屏蔽      
    279          //       if(abs_inductor(position - position_last) > 1)  //位置跳变过大时进入 
    280          //       {
    281          //            position = position_last;//此刻小车位置转变为上一次小车位置
    282          //       }
    283          //       else
    284          //       {
    285          //       position_last = position;//正常记录，接下来的上次小车位置=此刻小车位置
    286          //       }   
    287          ////zs屏蔽
    288          ////////弯道内和导线夹角过大导致后面转向不足，此时过渡点强制增大//////////////
    289          ///*用于小车直道太偏或过弯道时小车转弯幅度小不给力，小车不能好好的给过弯道，此时强制*/
    290          ////当在直道整个小车太过偏左都在电磁线左边时且此时最强的右电感值<75,说明小车太偏了，进入if
    291          ////当遇到弯道小车转弯幅度不够，可能会冲出赛道，进入if 
    292          //       
    293          //      //////弯道内和导线夹角过大导致后面转向不足，此时过渡点强制增大//////////////
    294          ////张盛屏蔽
    295          ////       if(position == 0 && AD_0_max < 75)
    296          ////       {
    297          ////           AD_0_max = 75 + abs_f(75 - AD_0_max);
    298          ////       }
    299          ////       else if(position == 3 && AD_2_max < 75)
    300          ////       {
    301          ////           AD_2_max = 75 + abs_f(75 - AD_2_max);
    302          ////       }
    303          ////张盛屏蔽
    304          //  Chazhi_Last=Chazhi;
    305          //       /*************计算偏移量*************/
    306          ////zs
    307          ////    Chazhi = (int16)(AD_inductor[2] - AD_inductor[0]);
    308          ////   if(position ==1)  
    309          ////   {
    310          ////      if(AD_inductor[0]>50&&AD_inductor[0]>AD_inductor[1]&&AD_inductor[1]>AD_inductor[2]&&AD_inductor[2]<5)
    311          ////        Chazhi=-70;
    312          ////   }
    313          ////   
    314          ////    if(position ==2)  
    315          ////   {
    316          ////      if(AD_inductor[2]>50&&AD_inductor[2]>AD_inductor[1 ]&&AD_inductor[1]>AD_inductor[0]&&AD_inductor[0]<5)
    317          ////        Chazhi=70;
    318          ////   }
    319          //  
    320          //       if(position == 0)   //左侧丢线
    321          //       {
    322          //       
    323          //            Chazhi =-60;
    324          //       }
    325          //       else if(position == 1 || position == 2) //处于中间位置        
    326          //       {
    327          //                  
    328          //             Chazhi = (int16)(AD_inductor[2] - AD_inductor[0]); 
    329          //             
    330          //             
    331          //       }
    332          //       else if(position == 3)  //右侧丢线
    333          //       {
    334          //            Chazhi = 60;
    335          //       }
    336          //     
    337          //
    338          //      
    339          //       /*
    340          //       if(Strig  ht_Flag)
    341          //       {
    342          //           Chazhi = (int16)(((AD_inductor[2]-AD_inductor[0])-(AD_inductor[4]-AD_inductor[3])/10)*1.3);  //长直道用斜率控制舵机
    343          //       }
    344          //       if(UPhill_flag)  //上坡时 强制用两侧电感偏移量
    345          //       {
    346          //           Chazhi = (int16)((AD_inductor[2] - AD_inductor[0]));
    347          //       }
    348          //       */
    349          //       
    350          //         
    351          //       
    352          //
    353          //}
    354          //
    355          //
    356          
    357          
    358          
    359          
    360          
    361          
    362          //延时

   \                                 In section .text, align 2, keep-with-next
    363          void delayms(unsigned int time)
    364          {
   \                     delayms: (+1)
   \   00000000   0xB500             PUSH     {LR}
    365             unsigned int i=0;
   \   00000002   0x2100             MOVS     R1,#+0
    366             while(time--)
   \                     ??delayms_0: (+1)
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0x1E48             SUBS     R0,R1,#+1
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD005             BEQ      ??delayms_1
    367             {
    368                i=12000;  //自己定义
   \   0000000C   0x....             LDR      R1,??DataTable1_4  ;; 0x2ee0
    369                while(i--);
   \                     ??delayms_2: (+1)
   \   0000000E   0x000A             MOVS     R2,R1
   \   00000010   0x1E51             SUBS     R1,R2,#+1
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD1FB             BNE      ??delayms_2
   \   00000016   0xE7F5             B        ??delayms_0
    370             }
    371          }
   \                     ??delayms_1: (+1)
   \   00000018   0xBD00             POP      {PC}             ;; return
    372          
    373          ///取绝对值

   \                                 In section .text, align 2, keep-with-next
    374          uint16 abs_inductor(int value)
    375          {
   \                     abs_inductor: (+1)
   \   00000000   0xB500             PUSH     {LR}
    376              if(value<0)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD501             BPL      ??abs_inductor_0
    377                value=-value;
   \   00000006   0x4241             RSBS     R1,R0,#+0
   \   00000008   0x0008             MOVS     R0,R1
    378              return value;
   \                     ??abs_inductor_0: (+1)
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0xBD00             POP      {PC}             ;; return
    379          }
    380          

   \                                 In section .text, align 2, keep-with-next
    381          float abs_f(float value)
    382          {
   \                     abs_f: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    383              if(value<0)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000008   0xD202             BCS      ??abs_f_0
    384                value=-value;
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x0609             LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000000E   0x4048             EORS     R0,R0,R1
    385              return value;
   \                     ??abs_f_0: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    386          }
    387          
    388          
    389          
    390          
    391          /*************************************************************************
    392           *  函数名称   SC_black_Init
    393           *  功能说明： AD初始化  将电感的最大值 以及 过渡点写入FLASH
    394           *  参数说明：
    395           *  函数返回： 无
    396           *  修改时间：
    397           *  备    注：
    398          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    399          void SC_black_Init(void)
    400          {
    401          //    uint16  i,j;
    402          //    float  *Ptr_flash=NULL;
    403          //    int16   Position_transit_short[4];
    404          //    float  sensor_1,sensor_2,sensor_3,sensor_4;
    405          //    flag_1 = 1;
    406          //
    407          //    if(inductor_flag)
    408          //    {
    409          //     inductor_flag = 0;
    410          ////     UART_Send_String("Collecting");
    411          ////     UART_Send_String("samples...");
    412          //
    413          //        max_v[0] = max_v[1] = max_v[2] = max_v[3] = max_v[4] = 0;
    414          //        for(i=0;i<100;i++)
    415          //        {
    416          //
    417          //            AD_valu[0] = ADC_Once(ADC_1,adc10bit);  //左  通道
    418          //            AD_valu[1] = ADC_Once(ADC_2,adc10bit);  //中  通道
    419          //            AD_valu[2] = ADC_Once(ADC_3,adc10bit);  //右  通道
    420          ////            AD_valu[3] = ADC_Once(ADC_4,adc10bit);  //中1 通道
    421          ////            AD_valu[4] = ADC_Once(ADC_5,adc10bit);  //中2 通道
    422          //            if(AD_valu[2]>300) AD_valu[2] = 250;
    423          //            
    424          //            for(j=0;j<3;j++)
    425          //            {
    426          //                if(AD_valu[j] > max_v[j])
    427          //                {
    428          //                    max_v[j] = AD_valu[j];
    429          //                    if(j==0)    Position_transit_short[0] =  AD_valu[1];  //记录过渡点 电感值
    430          //                    if(j==2)    Position_transit_short[1] =  AD_valu[1];
    431          ////                    if(j==3)    Position_transit_short[2] =  AD_valu[4];
    432          ////                    if(j==4)    Position_transit_short[3] =  AD_valu[3];
    433          //                }
    434          //            }
    435          //          
    436          //        }
    437          //        /***************              记录的过渡点归一化                     ******************/
    438          //        sensor_1 = (float)(Position_transit_short[0] - min_v[1])/(float)(max_v[1] - min_v[1]);
    439          //        if(sensor_1 <= 0.0)  sensor_1 = 0.001;
    440          //        if(sensor_1 >= 1.0)  sensor_1 = 1.0;
    441          //
    442          //        sensor_2 = (float)(Position_transit_short[1] - min_v[1])/(float)(max_v[1] - min_v[1]);
    443          //        if(sensor_2 <= 0.0)  sensor_2 = 0.001;
    444          //        if(sensor_2 >= 1.0)  sensor_2 = 1.0;
    445          //
    446          ////        sensor_3 = (float)(Position_transit_short[2] - min_v[4])/(float)(max_v[4] - min_v[4]);
    447          ////        if(sensor_3 <= 0.0)  sensor_3 = 0.001;/
    448          ////        if(sensor_3 >= 1.0)  sensor_3 = 1.0;
    449          ////
    450          ////        sensor_4 = (float)(Position_transit_short[3] - min_v[3])/(float)(max_v[3] - min_v[3]);
    451          ////        if(sensor_4 <= 0.0)  sensor_4 = 0.001;
    452          ////        if(sensor_4 >= 1.0)  sensor_4 = 1.0;
    453          //
    454          //        //扩大过渡点的值
    455          //        Position_transit[0] = (int16)(100 * sensor_1);
    456          //        Position_transit[1] = (int16)(100 * sensor_2);
    457          ////        Position_transit[2] = (int16)(100 * sensor_3);
    458          ////        Position_transit[3] = (int16)(100 * sensor_4);
    459          //
    460          //
    461          //        //将过渡值和最大值写到FASH里面
    462          //    /*
    463          //        result=LPLD_Flash_SectorErase((uint32)SECTOR_ADM);//擦除254扇区
    464          //        if(result == FLASH_OK)printf(0,0,"Eraser successful!");
    465          //
    466          //
    467          //        result=LPLD_Flash_ByteProgram((uint32)SECTOR_ADM, (uint32*)max_v, DATA_SIZE*4); //电感标定的最大值写入扇区
    468          //        if(result == FLASH_OK)printf(0,0,"Write max successful!");
    469          //
    470          //
    471          //        result=LPLD_Flash_ByteProgram((uint32)SECTOR_ADM+20, (uint32*)Position_transit, 4*4);
    472          //        if(result == FLASH_OK)printf(0,0,"Write Position_transit successful!");
    473          //        */
    474          //
    475          //
    476          //        /*
    477          //        for(i=0;i<4;i++)                     //过渡点归一化值写入扇区
    478          //        {
    479          //           LPLD_Flash_ByteProgram(SECTOR_ADM,20+i*4,Position_transit[i]);
    480          //        }
    481          //        */
    482          ////    }
    483          //    
    484          ////    else
    485          ////    {
    486          ////        for(i=0;i<3;i++)
    487          ////        {
    488          ////          /*
    489          ////          Ptr_flash = (float*)SECTOR_ADM;  没写ROM 报错  改
    490          ////          */
    491          ////           for(j=0;j<5;j++)   //读取五个电感的采样标定的最大值
    492          ////           {
    493          ////               max_v[j] = *(Ptr_flash+j);
    494          ////           }
    495          ////           for(j=0;j<4;j++)  //读取过渡点
    496          ////           {
    497          ////              Position_transit[j] = *(Ptr_flash+20+j);
    498          ////           }
    499          ////
    500          ////           UART_Send_String("Reading");
    501          ////           UART_Send_String("samples...");
    502          ////          // delayms(10);
    503          ////        }
    504          //    }
    505          
    506          
    507           }
   \                     SC_black_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     ad_valu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     AD_V

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     AD_sum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     AD_valu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x00002EE0         DC32     0x2ee0
    508          
    509          
    510          
    511          
    512          
    513          
    514          
    515          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   Read_ADC
        40   -> ADC_Once
        40 __aeabi_idiv
       0   SC_black_Init
       8   abs_f
         8 __aeabi_cfcmple
       4   abs_inductor
       4   delayms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
     714  Read_ADC
       2  SC_black_Init
      18  abs_f
      14  abs_inductor
      26  delayms

 
 794 bytes in section .text
 
 794 bytes of CODE memory

Errors: none
Warnings: none
