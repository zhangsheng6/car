///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM       28/Sep/2018  18:58:02
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_i2c.c
//    Command line =  
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_i2c.c -D IAR -D
//        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -D DA_OLED -lCN
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\ -lB
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\ -o
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\Obj\
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M0+ -e --fpu=None --dlib_config
//        F:\IAR安装包\arm\INC\c\DLib_Config_Normal.h -I
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\device\H\ -I
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\user\H\ -I
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\system\ -I
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\lib\H\ -I
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\system\coreSupport\
//        -Ol
//    List file    =  
//        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\KEA128_i2c.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN GpioSet
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_uidiv
        EXTERN abs
        EXTERN bus_clk_khz

        PUBLIC I2CN
        PUBLIC MasterTransmission
        PUBLIC SlaveID
        PUBLIC i2c_Wait
        PUBLIC i2c_delay
        PUBLIC i2c_init
        PUBLIC i2c_read_reg
        PUBLIC i2c_read_reg_bytes
        PUBLIC i2c_write_reg

// I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_i2c.c
//    1 /*********************************************************************************************************************
//    2  * COPYRIGHT NOTICE
//    3  * Copyright (c) 2017,逐飞科技
//    4  * All rights reserved.
//    5  * 技术讨论QQ群：179029047
//    6  *
//    7  * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
//    8  * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
//    9  *
//   10  * @file       		KEA128_i2c
//   11  * @company	   		成都逐飞科技有限公司
//   12  * @author     		逐飞科技(QQ3184284598)
//   13  * @version    		v2.0
//   14  * @Software 		IAR 7.7 or MDK 5.23
//   15  * @Target core		S9KEA128AMLK
//   16  * @Taobao   		https://seekfree.taobao.com/
//   17  * @date       		2017-11-6
//   18  ********************************************************************************************************************/
//   19 
//   20 
//   21 #include "KEA128_i2c.h"
//   22 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   23 unsigned char MasterTransmission;
MasterTransmission:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   24 unsigned char SlaveID;
SlaveID:
        DS8 1
//   25 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//   26 I2C_Type * I2CN[2] = I2C_BASES; //定义两个指针数组保存 I2CN 的地址
I2CN:
        DATA
        DC32 40066000H, 40067000H
//   27 
//   28 
//   29 //等待 I2C_S  不会出现卡死的情况

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   30 void i2c_Wait(I2Cn_e i2cn)
//   31 {
i2c_Wait:
        PUSH     {R4,LR}
        MOVS     R4,R0
//   32     uint16 num;
//   33     uint16 wait_num=500;//等待次数，超过设定的次数将关闭硬件IIC，使用模拟IIC发出stop信号，然后在启动硬件IIC。
        MOVS     R1,#+250
        LSLS     R1,R1,#+1        ;; #+500
//   34                         //这里的500在通信速率为100K的时候可以正常使用，如果通信速率较低可以适当增加这个值。
//   35                         //经过测试可以在通信出错的时候，自动恢复。
//   36     while(( I2CN[i2cn]->S & I2C_S_IICIF_MASK)==0)
??i2c_Wait_0:
        LDR      R2,??DataTable2
        UXTB     R4,R4
        MOVS     R3,#+4
        MULS     R3,R4,R3
        LDR      R2,[R2, R3]
        LDRB     R2,[R2, #+3]
        LSLS     R2,R2,#+30
        BMI      ??i2c_Wait_1
//   37     {
//   38         num++;
        ADDS     R0,R0,#+1
//   39         if(num>wait_num)
        UXTH     R1,R1
        UXTH     R0,R0
        CMP      R1,R0
        BCS      ??i2c_Wait_0
//   40         {
//   41             I2CN[i2cn]->C1 = 0;
        MOVS     R0,#+0
        LDR      R1,??DataTable2
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+2]
//   42             if(i2cn == i2c0)    SIM->SCGC &= ~(uint32)SIM_SCGC_I2C0_MASK;
        UXTB     R4,R4
        CMP      R4,#+0
        BNE      ??i2c_Wait_2
        LDR      R0,??DataTable2_1  ;; 0x40048014
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable2_2  ;; 0xfffeffff
        ANDS     R1,R1,R0
        LDR      R0,??DataTable2_1  ;; 0x40048014
        STR      R1,[R0, #+0]
        B        ??i2c_Wait_3
//   43             else                SIM->SCGC &= ~(uint32)SIM_SCGC_I2C1_MASK;
??i2c_Wait_2:
        LDR      R0,??DataTable2_1  ;; 0x40048014
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable2_3  ;; 0xfffdffff
        ANDS     R1,R1,R0
        LDR      R0,??DataTable2_1  ;; 0x40048014
        STR      R1,[R0, #+0]
//   44 
//   45             LED_3_ON;//出错了，闪灯
??i2c_Wait_3:
        MOVS     R1,#+0
        MOVS     R0,#+51
        BL       GpioSet
//   46 //            carStatus = STOP;
//   47 //            IIC_init();
//   48 //            IIC_stop();
//   49             if(i2cn == i2c0)    SIM->SCGC |= SIM_SCGC_I2C0_MASK;
        UXTB     R4,R4
        CMP      R4,#+0
        BNE      ??i2c_Wait_4
        LDR      R0,??DataTable2_1  ;; 0x40048014
        LDR      R0,[R0, #+0]
        MOVS     R1,#+128
        LSLS     R1,R1,#+9        ;; #+65536
        ORRS     R1,R1,R0
        LDR      R0,??DataTable2_1  ;; 0x40048014
        STR      R1,[R0, #+0]
        B        ??i2c_Wait_5
//   50             else                SIM->SCGC |= SIM_SCGC_I2C1_MASK;
??i2c_Wait_4:
        LDR      R0,??DataTable2_1  ;; 0x40048014
        LDR      R0,[R0, #+0]
        MOVS     R1,#+128
        LSLS     R1,R1,#+10       ;; #+131072
        ORRS     R1,R1,R0
        LDR      R0,??DataTable2_1  ;; 0x40048014
        STR      R1,[R0, #+0]
//   51             I2CN[i2cn]->C1 = I2C_C1_IICEN_MASK;
??i2c_Wait_5:
        MOVS     R0,#+128
        LDR      R1,??DataTable2
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+2]
//   52             break;
//   53         }
//   54     }
//   55     I2CN[i2cn]->S |= I2C_S_IICIF_MASK ;
??i2c_Wait_1:
        LDR      R0,??DataTable2
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+3]
        MOVS     R1,#+2
        ORRS     R1,R1,R0
        LDR      R0,??DataTable2
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R4,R2,R4
        LDR      R0,[R0, R4]
        STRB     R1,[R0, #+3]
//   56 }
        POP      {R4,PC}          ;; return
//   57 
//   58 //启动信号
//   59 #define i2c_Start(NUM)             {I2CN[NUM]->C1 |= (I2C_C1_TX_MASK | I2C_C1_MST_MASK);}    //MST 由0变1，产生起始信号，TX = 1 进入发送模式
//   60 
//   61 //停止信号
//   62 #define i2c_Stop(NUM)              {I2CN[NUM]->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK);}   //MST 由1变0，产生停止信号，TX = 0 进入接收模式
//   63 
//   64 //重复启动
//   65 #define i2c_RepeatedStart(NUM)     {I2CN[NUM]->C1 |= I2C_C1_RSTA_MASK;}
//   66 
//   67 //进入接收模式(应答,需要接收多个数据，接收最后一个字节前需要禁用应答i2c_DisableAck)
//   68 #define i2c_EnterRxMode(NUM)       {I2CN[NUM]->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);}  //
//   69 
//   70 //进入接收模式(不应答,只接收一个字节)
//   71 #define i2c_PutinRxMode(NUM)       {I2CN[NUM]->C1 &= ~I2C_C1_TX_MASK; I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
//   72 
//   73 //禁用应答(接收最后一个字节)
//   74 #define i2c_DisableAck(NUM)        {I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
//   75 
//   76 //写一个字节
//   77 #define i2c_write_byte(NUM,data)   {I2CN[NUM]->D = data; i2c_Wait(NUM);}
//   78 
//   79 
//   80 
//   81 
//   82 //-------------------------------------------------------------------------------------------------------------------
//   83 //  @brief      I2C初始化
//   84 //  @param      i2cn        I2C模块(i2c0,i2c1)
//   85 //  @param      baud        期望的波特率
//   86 //  @return                 实际的波特率
//   87 //  @return     void
//   88 //  @since      v2.0
//   89 //  Sample usage:           i2c_init(i2c0,400*1000);     // 初始化i2c0，期望的波特率为400k
//   90 //-------------------------------------------------------------------------------------------------------------------

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   91 uint32 i2c_init(I2Cn_e i2cn, uint32 baud)
//   92 {
i2c_init:
        PUSH     {R0,R4-R7,LR}
        SUB      SP,SP,#+136
        MOVS     R6,R1
//   93     //查表 ICR 对应的  SCL_divider ，见 《KEA128RM.pdf》第537页的I2C 分频器和保持值
//   94     uint16 ICR_2_SCL_divider[0x40]  =
//   95     {
//   96         20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68,
//   97         48, 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240,
//   98         160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576, 640, 768, 960,
//   99         640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840
//  100     };
        ADD      R0,SP,#+4
        LDR      R1,??DataTable2_4
        MOVS     R2,#+128
        BL       __aeabi_memcpy4
//  101 
//  102     uint8 mult;
//  103 
//  104     uint16 scldiv =  0;  //最佳的分频系数
        MOVS     R5,#+0
//  105 
//  106     //需要从 ICR_2_SCL_divider 里找到 与最佳分频系数scldiv最相近的 分频系数
//  107     uint8 icr, n;
//  108     uint16 min_Dvalue = ~0, Dvalue;
        LDR      R4,??DataTable2_5  ;; 0xffff
//  109 
//  110     if(i2cn == i2c0)
        ADD      R0,SP,#+136
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??i2c_init_0
//  111     {
//  112         // 开启时钟
//  113         SIM->SCGC |= SIM_SCGC_I2C0_MASK;           //开启 I2C0时钟
        LDR      R0,??DataTable2_1  ;; 0x40048014
        LDR      R0,[R0, #+0]
        MOVS     R1,#+128
        LSLS     R1,R1,#+9        ;; #+65536
        ORRS     R1,R1,R0
        LDR      R0,??DataTable2_1  ;; 0x40048014
        STR      R1,[R0, #+0]
//  114         //复用引脚
//  115         if(A3 == I2C0_SCL_PIN)
//  116         {
//  117             SIM->PINSEL &= ~(uint32)SIM_PINSEL_I2C0PS_MASK;
        LDR      R0,??DataTable3  ;; 0x4004800c
        LDR      R0,[R0, #+0]
        MOVS     R1,#+32
        BICS     R0,R0,R1
        LDR      R1,??DataTable3  ;; 0x4004800c
        STR      R0,[R1, #+0]
        B        ??i2c_init_1
//  118         }
//  119         else
//  120         {
//  121             SIM->PINSEL |= SIM_PINSEL_I2C0PS_MASK;
//  122         }
//  123 
//  124     }
//  125     else
//  126     {
//  127         // 开启时钟
//  128         SIM->SCGC |= SIM_SCGC_I2C1_MASK;           //开启 I2C1时钟
??i2c_init_0:
        LDR      R0,??DataTable2_1  ;; 0x40048014
        LDR      R0,[R0, #+0]
        MOVS     R1,#+128
        LSLS     R1,R1,#+10       ;; #+131072
        ORRS     R1,R1,R0
        LDR      R0,??DataTable2_1  ;; 0x40048014
        STR      R1,[R0, #+0]
//  129         //复用引脚
//  130         if(E1 == I2C1_SCL_PIN)
//  131         {
//  132             SIM->PINSEL1 &= ~(uint32)SIM_PINSEL1_I2C1PS_MASK;
//  133         }
//  134         else
//  135         {
//  136             SIM->PINSEL1 |= SIM_PINSEL1_I2C1PS_MASK;
        LDR      R0,??DataTable3_1  ;; 0x40048010
        LDR      R0,[R0, #+0]
        MOVS     R1,#+128
        LSLS     R1,R1,#+3        ;; #+1024
        ORRS     R1,R1,R0
        LDR      R0,??DataTable3_1  ;; 0x40048010
        STR      R1,[R0, #+0]
//  137         }
//  138     }
//  139 
//  140     // 设置频率
//  141 
//  142     // I2C baud rate = bus speed (Hz)/(mul × SCL divider)
//  143     // SDA hold time = bus period (s) × mul × SDA hold value
//  144     // SCL start hold time = bus period (s) × mul × SCL start hold value
//  145     // SCL stop hold time = bus period (s) × mul × SCL stop hold value
//  146 
//  147 
//  148     mult = bus_clk_khz*1000/baud/3840;
??i2c_init_1:
        LDR      R0,??DataTable3_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+250
        LSLS     R1,R1,#+2        ;; #+1000
        MULS     R0,R1,R0
        MOVS     R1,R6
        BL       __aeabi_uidiv
        MOVS     R1,#+240
        LSLS     R1,R1,#+4        ;; #+3840
        BL       __aeabi_uidiv
        MOV      R1,SP
        STRB     R0,[R1, #+0]
//  149 
//  150     scldiv =  bus_clk_khz * 1000 / ( (1<<mult) * baud );    //最佳的分频系数
        LDR      R0,??DataTable3_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+250
        LSLS     R1,R1,#+2        ;; #+1000
        MULS     R0,R1,R0
        MOVS     R1,#+1
        MOV      R2,SP
        LDRB     R2,[R2, #+0]
        LSLS     R1,R1,R2
        MULS     R1,R6,R1
        BL       __aeabi_uidiv
        MOVS     R5,R0
//  151 
//  152     n = 0x40;
        MOVS     R6,#+64
        B        ??i2c_init_2
//  153     while(n)                                                //循环里逐个扫描，找出最接近的 分频系数
//  154     {
//  155         n--;
//  156         Dvalue = abs(scldiv - ICR_2_SCL_divider[n]);
//  157         if(Dvalue == 0)
//  158         {
//  159             icr = n;
//  160             break;                                          //退出while循环
//  161         }
//  162 
//  163         if(Dvalue < min_Dvalue)
??i2c_init_3:
        UXTH     R0,R0
        UXTH     R4,R4
        CMP      R0,R4
        BCS      ??i2c_init_2
//  164         {
//  165             icr = n;
        MOVS     R7,R6
//  166             min_Dvalue = Dvalue;
        MOVS     R4,R0
//  167         }
??i2c_init_2:
        UXTB     R6,R6
        CMP      R6,#+0
        BEQ      ??i2c_init_4
        SUBS     R6,R6,#+1
        UXTH     R5,R5
        ADD      R0,SP,#+4
        UXTB     R6,R6
        MOVS     R1,#+2
        MULS     R1,R6,R1
        LDRH     R0,[R0, R1]
        SUBS     R0,R5,R0
        BL       abs
        UXTH     R0,R0
        CMP      R0,#+0
        BNE      ??i2c_init_3
        MOVS     R7,R6
//  168     }
//  169 
//  170     I2CN[i2cn]->F  = I2C_F_MULT(mult) | I2C_F_ICR(icr);     // I2C分频寄存器
??i2c_init_4:
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+6
        LSLS     R1,R7,#+26       ;; ZeroExtS R1,R7,#+26,#+26
        LSRS     R1,R1,#+26
        ORRS     R1,R1,R0
        LDR      R0,??DataTable2
        ADD      R2,SP,#+136
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+4
        MULS     R2,R3,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+1]
//  171 
//  172     // 使能 I2C
//  173     I2CN[i2cn]->C1 = ( 0
//  174                        | I2C_C1_IICEN_MASK       //使能I2C
//  175                        //| I2C_C1_IICIE_MASK       //使能中断
//  176                      );
        MOVS     R0,#+128
        LDR      R1,??DataTable2
        ADD      R2,SP,#+136
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+4
        MULS     R2,R3,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+2]
//  177 
//  178     return (  bus_clk_khz * 1000 / ( (1<<mult) * ICR_2_SCL_divider[icr])  );
        LDR      R0,??DataTable3_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+250
        LSLS     R1,R1,#+2        ;; #+1000
        MULS     R0,R1,R0
        MOVS     R1,#+1
        MOV      R2,SP
        LDRB     R2,[R2, #+0]
        LSLS     R1,R1,R2
        ADD      R2,SP,#+4
        UXTB     R7,R7
        MOVS     R3,#+2
        MULS     R7,R3,R7
        LDRH     R2,[R2, R7]
        MULS     R1,R2,R1
        BL       __aeabi_uidiv
        ADD      SP,SP,#+140
        POP      {R4-R7,PC}       ;; return
//  179 }
//  180 
//  181 //-------------------------------------------------------------------------------------------------------------------
//  182 //  @brief      I2C通信结束后需要调用的函数函数
//  183 //  @return     void
//  184 //  @since      v2.0
//  185 //  @note		如果通信失败，可尝试增大此延时值，确认是否延时导致的
//  186 //-------------------------------------------------------------------------------------------------------------------

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  187 void i2c_delay(void)
//  188 {
i2c_delay:
        PUSH     {R7,LR}
//  189     volatile uint16 n = 150;     //注意，这个数据太小，会导致读取错误。
        MOVS     R0,#+150
        MOV      R1,SP
        STRH     R0,[R1, #+0]
//  190 
//  191     while(n--);
??i2c_delay_0:
        MOV      R0,SP
        LDRH     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        MOV      R2,SP
        STRH     R1,[R2, #+0]
        UXTH     R0,R0
        CMP      R0,#+0
        BNE      ??i2c_delay_0
//  192 }
        POP      {R0,PC}          ;; return
//  193 
//  194 //-------------------------------------------------------------------------------------------------------------------
//  195 //  @brief      读取I2C设备指定地址寄存器的数据
//  196 //  @param      i2cn        I2C模块(i2c0、i2c1)
//  197 //  @param      SlaveID     从机地址(7位地址)
//  198 //  @param      reg         从机寄存器地址
//  199 //  @return                 读取的寄存器值
//  200 //  @since      v2.0
//  201 //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50);//读取0x50地址的数据，从机地址为0x2D
//  202 //-------------------------------------------------------------------------------------------------------------------

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  203 uint8 i2c_read_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg)
//  204 {
i2c_read_reg:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  205 
//  206     //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
//  207     //地址是低七位
//  208     uint8 result;
//  209 
//  210     i2c_Start(i2cn);                                    //发送启动信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+48
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  211 
//  212     i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
        LSLS     R0,R5,#+1
        LDR      R1,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  213 
//  214     i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        STRB     R6,[R0, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  215 
//  216     i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+4
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  217 
//  218     i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
        LSLS     R0,R5,#+1
        MOVS     R1,#+1
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  219 
//  220     i2c_PutinRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+239
        ANDS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+8
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  221     result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R5,[R0, #+4]
//  222     i2c_Wait(i2cn);                                     //等待接收完成
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  223 
//  224     i2c_Stop(i2cn);                                     //发送停止信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+207
        ANDS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  225 
//  226     result = I2CN[i2cn]->D;                             //读取数据
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R4,R1,R4
        LDR      R0,[R0, R4]
        LDRB     R5,[R0, #+4]
//  227 
//  228     i2c_delay();                                        //必须延时一下，否则出错
        BL       i2c_delay
//  229 
//  230     return result;
        MOVS     R0,R5
        UXTB     R0,R0
        POP      {R4-R6,PC}       ;; return
//  231 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2:
        DC32     I2CN

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_1:
        DC32     0x40048014

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_2:
        DC32     0xfffeffff

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_3:
        DC32     0xfffdffff

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_4:
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_5:
        DC32     0xffff
//  232 
//  233 //-------------------------------------------------------------------------------------------------------------------
//  234 //  @brief      读取I2C设备指定地址寄存器的数据
//  235 //  @param      i2cn        I2C模块(i2c0、i2c1)
//  236 //  @param      SlaveID     从机地址(7位地址)
//  237 //  @param      reg         从机寄存器地址
//  238 //  @param      num         读取字节数
//  239 //  @param      addr        读取的数据存储的地址
//  240 //  @return     void
//  241 //  @since      v2.0
//  242 //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50, 10, buf);//读取0x50地址的数据，从机地址为0x2D开始的10个字节
//  243 //-------------------------------------------------------------------------------------------------------------------
//  244 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  245 uint8 i2c_read_reg_bytes(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 num, uint8 * addr)
//  246 {
i2c_read_reg_bytes:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R7,R1
        MOVS     R5,R2
        MOVS     R6,R3
//  247     //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
//  248     //地址是低七位
//  249     uint8 result;
//  250 
//  251     i2c_Start(i2cn);                                    //发送启动信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R1,[R0, #+2]
        MOVS     R0,#+48
        ORRS     R0,R0,R1
        LDR      R1,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+2]
//  252 
//  253     i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
        LSLS     R0,R7,#+1
        LDR      R1,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  254 
//  255     i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        STRB     R5,[R0, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  256 
//  257     i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+4
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  258 
//  259     i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
        LSLS     R0,R7,#+1
        MOVS     R1,#+1
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  260 
//  261     i2c_EnterRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+231
        ANDS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
        LDR      R5,[SP, #+24]
        B        ??i2c_read_reg_bytes_0
//  262 
//  263     while(num--)
//  264     {
//  265         result = I2CN[i2cn]->D;                         //虚假读取一次，启动接收数据
??i2c_read_reg_bytes_1:
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R7,[R0, #+4]
//  266         i2c_Wait(i2cn);                                 //等待接收完成
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  267         *addr = I2CN[i2cn]->D;                         //读取数据
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+4]
        STRB     R0,[R5, #+0]
//  268         i2c_delay();                                    //必须延时一下，否则出错
        BL       i2c_delay
//  269         addr++;
        ADDS     R5,R5,#+1
//  270     }
??i2c_read_reg_bytes_0:
        MOVS     R0,R6
        SUBS     R6,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        BNE      ??i2c_read_reg_bytes_1
//  271     i2c_DisableAck(i2cn);
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+8
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  272     i2c_PutinRxMode(i2cn);
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+239
        ANDS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+8
        ORRS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  273     result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R7,[R0, #+4]
//  274     i2c_Wait(i2cn);                                     //等待接收完成
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  275     i2c_Stop(i2cn);                                     //发送停止信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+207
        ANDS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        STRB     R1,[R0, #+2]
//  276     *addr = I2CN[i2cn]->D;                              //读取数据
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R4,R1,R4
        LDR      R0,[R0, R4]
        LDRB     R0,[R0, #+4]
        STRB     R0,[R5, #+0]
//  277 
//  278     i2c_delay();                                        //必须延时一下，否则出错
        BL       i2c_delay
//  279 
//  280     return result;
        MOVS     R0,R7
        UXTB     R0,R0
        POP      {R1,R4-R7,PC}    ;; return
//  281 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3:
        DC32     0x4004800c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_1:
        DC32     0x40048010

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_2:
        DC32     bus_clk_khz
//  282 
//  283 //-------------------------------------------------------------------------------------------------------------------
//  284 //  @brief      写入一个字节数据到I2C设备指定寄存器地址
//  285 //  @param      i2cn        I2C模块(i2c0、i2c1)
//  286 //  @param      SlaveID     从机地址(7位地址)
//  287 //  @param      reg         从机寄存器地址
//  288 //  @param      Data        数据
//  289 //  @return     void
//  290 //  @since      v2.0
//  291 //  Sample usage:       	i2c_write_reg(i2c0, 0x2D, 0x50,2);     //写入数据2到0x50地址，从机地址为0x2D
//  292 //-------------------------------------------------------------------------------------------------------------------

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  293 void i2c_write_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 Data)
//  294 {
i2c_write_reg:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R2
        MOVS     R6,R3
//  295 
//  296     i2c_Start(i2cn);                                    //发送启动信号
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R0,[R0, R2]
        LDRB     R2,[R0, #+2]
        MOVS     R0,#+48
        ORRS     R0,R0,R2
        LDR      R2,??DataTable4
        UXTB     R4,R4
        MOVS     R3,#+4
        MULS     R3,R4,R3
        LDR      R2,[R2, R3]
        STRB     R0,[R2, #+2]
//  297 
//  298     i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
        LSLS     R0,R1,#+1
        LDR      R1,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R2,R4,R2
        LDR      R1,[R1, R2]
        STRB     R0,[R1, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  299 
//  300     i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        STRB     R5,[R0, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  301 
//  302     i2c_write_byte(i2cn, Data);                         //发送需要写入的数据
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        STRB     R6,[R0, #+4]
        MOVS     R0,R4
        UXTB     R0,R0
        BL       i2c_Wait
//  303 
//  304     i2c_Stop(i2cn);
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R1,#+4
        MULS     R1,R4,R1
        LDR      R0,[R0, R1]
        LDRB     R0,[R0, #+2]
        MOVS     R1,#+207
        ANDS     R1,R1,R0
        LDR      R0,??DataTable4
        UXTB     R4,R4
        MOVS     R2,#+4
        MULS     R4,R2,R4
        LDR      R0,[R0, R4]
        STRB     R1,[R0, #+2]
//  305 
//  306     i2c_delay();                                        //延时太短的话，可能写出错
        BL       i2c_delay
//  307 }
        POP      {R4-R6,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable4:
        DC32     I2CN

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_0:
        DATA
        DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
        DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
        DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
        DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
        DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840

        END
// 
//     2 bytes in section .bss
//     8 bytes in section .data
//   128 bytes in section .rodata
// 1 264 bytes in section .text
// 
// 1 264 bytes of CODE  memory
//   128 bytes of CONST memory
//    10 bytes of DATA  memory
//
//Errors: none
//Warnings: none
