###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        28/Sep/2018  18:58:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_i2c.c
#    Command line =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_i2c.c -D IAR -D
#        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -D DA_OLED -lCN
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\ -lB
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\ -o
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        F:\IAR安装包\arm\INC\c\DLib_Config_Normal.h -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\device\H\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\user\H\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\system\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\lib\H\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\system\coreSupport\
#        -Ol
#    List file    =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\KEA128_i2c.lst
#    Object file  =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\Obj\KEA128_i2c.o
#
###############################################################################

I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_i2c.c
      1          /*********************************************************************************************************************
      2           * COPYRIGHT NOTICE
      3           * Copyright (c) 2017,逐飞科技
      4           * All rights reserved.
      5           * 技术讨论QQ群：179029047
      6           *
      7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
      8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
      9           *
     10           * @file       		KEA128_i2c
     11           * @company	   		成都逐飞科技有限公司
     12           * @author     		逐飞科技(QQ3184284598)
     13           * @version    		v2.0
     14           * @Software 		IAR 7.7 or MDK 5.23
     15           * @Target core		S9KEA128AMLK
     16           * @Taobao   		https://seekfree.taobao.com/
     17           * @date       		2017-11-6
     18           ********************************************************************************************************************/
     19          
     20          
     21          #include "KEA128_i2c.h"
     22          

   \                                 In section .bss, align 1
     23          unsigned char MasterTransmission;
   \                     MasterTransmission:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     24          unsigned char SlaveID;
   \                     SlaveID:
   \   00000000                      DS8 1
     25          

   \                                 In section .data, align 4
     26          I2C_Type * I2CN[2] = I2C_BASES; //定义两个指针数组保存 I2CN 的地址
   \                     I2CN:
   \   00000000   0x40066000         DC32 40066000H, 40067000H
   \              0x40067000   
     27          
     28          
     29          //等待 I2C_S  不会出现卡死的情况

   \                                 In section .text, align 2, keep-with-next
     30          void i2c_Wait(I2Cn_e i2cn)
     31          {
   \                     i2c_Wait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     32              uint16 num;
     33              uint16 wait_num=500;//等待次数，超过设定的次数将关闭硬件IIC，使用模拟IIC发出stop信号，然后在启动硬件IIC。
   \   00000004   0x21FA             MOVS     R1,#+250
   \   00000006   0x0049             LSLS     R1,R1,#+1        ;; #+500
     34                                  //这里的500在通信速率为100K的时候可以正常使用，如果通信速率较低可以适当增加这个值。
     35                                  //经过测试可以在通信出错的时候，自动恢复。
     36              while(( I2CN[i2cn]->S & I2C_S_IICIF_MASK)==0)
   \                     ??i2c_Wait_0: (+1)
   \   00000008   0x....             LDR      R2,??DataTable2
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2304             MOVS     R3,#+4
   \   0000000E   0x4363             MULS     R3,R4,R3
   \   00000010   0x58D2             LDR      R2,[R2, R3]
   \   00000012   0x78D2             LDRB     R2,[R2, #+3]
   \   00000014   0x0792             LSLS     R2,R2,#+30
   \   00000016   0xD438             BMI      ??i2c_Wait_1
     37              {
     38                  num++;
   \   00000018   0x1C40             ADDS     R0,R0,#+1
     39                  if(num>wait_num)
   \   0000001A   0xB289             UXTH     R1,R1
   \   0000001C   0xB280             UXTH     R0,R0
   \   0000001E   0x4281             CMP      R1,R0
   \   00000020   0xD2F2             BCS      ??i2c_Wait_0
     40                  {
     41                      I2CN[i2cn]->C1 = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable2
   \   00000026   0xB2E4             UXTB     R4,R4
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0x4362             MULS     R2,R4,R2
   \   0000002C   0x5889             LDR      R1,[R1, R2]
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
     42                      if(i2cn == i2c0)    SIM->SCGC &= ~(uint32)SIM_SCGC_I2C0_MASK;
   \   00000030   0xB2E4             UXTB     R4,R4
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD106             BNE      ??i2c_Wait_2
   \   00000036   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x....             LDR      R1,??DataTable2_2  ;; 0xfffeffff
   \   0000003C   0x4001             ANDS     R1,R1,R0
   \   0000003E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0xE005             B        ??i2c_Wait_3
     43                      else                SIM->SCGC &= ~(uint32)SIM_SCGC_I2C1_MASK;
   \                     ??i2c_Wait_2: (+1)
   \   00000044   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x....             LDR      R1,??DataTable2_3  ;; 0xfffdffff
   \   0000004A   0x4001             ANDS     R1,R1,R0
   \   0000004C   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000004E   0x6001             STR      R1,[R0, #+0]
     44          
     45                      LED_3_ON;//出错了，闪灯
   \                     ??i2c_Wait_3: (+1)
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2033             MOVS     R0,#+51
   \   00000054   0x.... 0x....      BL       GpioSet
     46          //            carStatus = STOP;
     47          //            IIC_init();
     48          //            IIC_stop();
     49                      if(i2cn == i2c0)    SIM->SCGC |= SIM_SCGC_I2C0_MASK;
   \   00000058   0xB2E4             UXTB     R4,R4
   \   0000005A   0x2C00             CMP      R4,#+0
   \   0000005C   0xD107             BNE      ??i2c_Wait_4
   \   0000005E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2180             MOVS     R1,#+128
   \   00000064   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000066   0x4301             ORRS     R1,R1,R0
   \   00000068   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   \   0000006C   0xE006             B        ??i2c_Wait_5
     50                      else                SIM->SCGC |= SIM_SCGC_I2C1_MASK;
   \                     ??i2c_Wait_4: (+1)
   \   0000006E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x2180             MOVS     R1,#+128
   \   00000074   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   00000076   0x4301             ORRS     R1,R1,R0
   \   00000078   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000007A   0x6001             STR      R1,[R0, #+0]
     51                      I2CN[i2cn]->C1 = I2C_C1_IICEN_MASK;
   \                     ??i2c_Wait_5: (+1)
   \   0000007C   0x2080             MOVS     R0,#+128
   \   0000007E   0x....             LDR      R1,??DataTable2
   \   00000080   0xB2E4             UXTB     R4,R4
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0x4362             MULS     R2,R4,R2
   \   00000086   0x5889             LDR      R1,[R1, R2]
   \   00000088   0x7088             STRB     R0,[R1, #+2]
     52                      break;
     53                  }
     54              }
     55              I2CN[i2cn]->S |= I2C_S_IICIF_MASK ;
   \                     ??i2c_Wait_1: (+1)
   \   0000008A   0x....             LDR      R0,??DataTable2
   \   0000008C   0xB2E4             UXTB     R4,R4
   \   0000008E   0x2104             MOVS     R1,#+4
   \   00000090   0x4361             MULS     R1,R4,R1
   \   00000092   0x5840             LDR      R0,[R0, R1]
   \   00000094   0x78C0             LDRB     R0,[R0, #+3]
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x4301             ORRS     R1,R1,R0
   \   0000009A   0x....             LDR      R0,??DataTable2
   \   0000009C   0xB2E4             UXTB     R4,R4
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0x4354             MULS     R4,R2,R4
   \   000000A2   0x5900             LDR      R0,[R0, R4]
   \   000000A4   0x70C1             STRB     R1,[R0, #+3]
     56          }
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
     57          
     58          //启动信号
     59          #define i2c_Start(NUM)             {I2CN[NUM]->C1 |= (I2C_C1_TX_MASK | I2C_C1_MST_MASK);}    //MST 由0变1，产生起始信号，TX = 1 进入发送模式
     60          
     61          //停止信号
     62          #define i2c_Stop(NUM)              {I2CN[NUM]->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK);}   //MST 由1变0，产生停止信号，TX = 0 进入接收模式
     63          
     64          //重复启动
     65          #define i2c_RepeatedStart(NUM)     {I2CN[NUM]->C1 |= I2C_C1_RSTA_MASK;}
     66          
     67          //进入接收模式(应答,需要接收多个数据，接收最后一个字节前需要禁用应答i2c_DisableAck)
     68          #define i2c_EnterRxMode(NUM)       {I2CN[NUM]->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);}  //
     69          
     70          //进入接收模式(不应答,只接收一个字节)
     71          #define i2c_PutinRxMode(NUM)       {I2CN[NUM]->C1 &= ~I2C_C1_TX_MASK; I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
     72          
     73          //禁用应答(接收最后一个字节)
     74          #define i2c_DisableAck(NUM)        {I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
     75          
     76          //写一个字节
     77          #define i2c_write_byte(NUM,data)   {I2CN[NUM]->D = data; i2c_Wait(NUM);}
     78          
     79          
     80          
     81          
     82          //-------------------------------------------------------------------------------------------------------------------
     83          //  @brief      I2C初始化
     84          //  @param      i2cn        I2C模块(i2c0,i2c1)
     85          //  @param      baud        期望的波特率
     86          //  @return                 实际的波特率
     87          //  @return     void
     88          //  @since      v2.0
     89          //  Sample usage:           i2c_init(i2c0,400*1000);     // 初始化i2c0，期望的波特率为400k
     90          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     91          uint32 i2c_init(I2Cn_e i2cn, uint32 baud)
     92          {
   \                     i2c_init: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB0A2             SUB      SP,SP,#+136
   \   00000004   0x000E             MOVS     R6,R1
     93              //查表 ICR 对应的  SCL_divider ，见 《KEA128RM.pdf》第537页的I2C 分频器和保持值
     94              uint16 ICR_2_SCL_divider[0x40]  =
     95              {
     96                  20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68,
     97                  48, 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240,
     98                  160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576, 640, 768, 960,
     99                  640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840
    100              };
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x....             LDR      R1,??DataTable2_4
   \   0000000A   0x2280             MOVS     R2,#+128
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    101          
    102              uint8 mult;
    103          
    104              uint16 scldiv =  0;  //最佳的分频系数
   \   00000010   0x2500             MOVS     R5,#+0
    105          
    106              //需要从 ICR_2_SCL_divider 里找到 与最佳分频系数scldiv最相近的 分频系数
    107              uint8 icr, n;
    108              uint16 min_Dvalue = ~0, Dvalue;
   \   00000012   0x....             LDR      R4,??DataTable2_5  ;; 0xffff
    109          
    110              if(i2cn == i2c0)
   \   00000014   0xA822             ADD      R0,SP,#+136
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10D             BNE      ??i2c_init_0
    111              {
    112                  // 开启时钟
    113                  SIM->SCGC |= SIM_SCGC_I2C0_MASK;           //开启 I2C0时钟
   \   0000001C   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2180             MOVS     R1,#+128
   \   00000022   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000024   0x4301             ORRS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000028   0x6001             STR      R1,[R0, #+0]
    114                  //复用引脚
    115                  if(A3 == I2C0_SCL_PIN)
    116                  {
    117                      SIM->PINSEL &= ~(uint32)SIM_PINSEL_I2C0PS_MASK;
   \   0000002A   0x....             LDR      R0,??DataTable3  ;; 0x4004800c
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2120             MOVS     R1,#+32
   \   00000030   0x4388             BICS     R0,R0,R1
   \   00000032   0x....             LDR      R1,??DataTable3  ;; 0x4004800c
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE00D             B        ??i2c_init_1
    118                  }
    119                  else
    120                  {
    121                      SIM->PINSEL |= SIM_PINSEL_I2C0PS_MASK;
    122                  }
    123          
    124              }
    125              else
    126              {
    127                  // 开启时钟
    128                  SIM->SCGC |= SIM_SCGC_I2C1_MASK;           //开启 I2C1时钟
   \                     ??i2c_init_0: (+1)
   \   00000038   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   00000040   0x4301             ORRS     R1,R1,R0
   \   00000042   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000044   0x6001             STR      R1,[R0, #+0]
    129                  //复用引脚
    130                  if(E1 == I2C1_SCL_PIN)
    131                  {
    132                      SIM->PINSEL1 &= ~(uint32)SIM_PINSEL1_I2C1PS_MASK;
    133                  }
    134                  else
    135                  {
    136                      SIM->PINSEL1 |= SIM_PINSEL1_I2C1PS_MASK;
   \   00000046   0x....             LDR      R0,??DataTable3_1  ;; 0x40048010
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x2180             MOVS     R1,#+128
   \   0000004C   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   0000004E   0x4301             ORRS     R1,R1,R0
   \   00000050   0x....             LDR      R0,??DataTable3_1  ;; 0x40048010
   \   00000052   0x6001             STR      R1,[R0, #+0]
    137                  }
    138              }
    139          
    140              // 设置频率
    141          
    142              // I2C baud rate = bus speed (Hz)/(mul × SCL divider)
    143              // SDA hold time = bus period (s) × mul × SDA hold value
    144              // SCL start hold time = bus period (s) × mul × SCL start hold value
    145              // SCL stop hold time = bus period (s) × mul × SCL stop hold value
    146          
    147          
    148              mult = bus_clk_khz*1000/baud/3840;
   \                     ??i2c_init_1: (+1)
   \   00000054   0x....             LDR      R0,??DataTable3_2
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x21FA             MOVS     R1,#+250
   \   0000005A   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   0000005C   0x4348             MULS     R0,R1,R0
   \   0000005E   0x0031             MOVS     R1,R6
   \   00000060   0x.... 0x....      BL       __aeabi_uidiv
   \   00000064   0x21F0             MOVS     R1,#+240
   \   00000066   0x0109             LSLS     R1,R1,#+4        ;; #+3840
   \   00000068   0x.... 0x....      BL       __aeabi_uidiv
   \   0000006C   0x4669             MOV      R1,SP
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
    149          
    150              scldiv =  bus_clk_khz * 1000 / ( (1<<mult) * baud );    //最佳的分频系数
   \   00000070   0x....             LDR      R0,??DataTable3_2
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x21FA             MOVS     R1,#+250
   \   00000076   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000078   0x4348             MULS     R0,R1,R0
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x466A             MOV      R2,SP
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0x4091             LSLS     R1,R1,R2
   \   00000082   0x4371             MULS     R1,R6,R1
   \   00000084   0x.... 0x....      BL       __aeabi_uidiv
   \   00000088   0x0005             MOVS     R5,R0
    151          
    152              n = 0x40;
   \   0000008A   0x2640             MOVS     R6,#+64
   \   0000008C   0xE005             B        ??i2c_init_2
    153              while(n)                                                //循环里逐个扫描，找出最接近的 分频系数
    154              {
    155                  n--;
    156                  Dvalue = abs(scldiv - ICR_2_SCL_divider[n]);
    157                  if(Dvalue == 0)
    158                  {
    159                      icr = n;
    160                      break;                                          //退出while循环
    161                  }
    162          
    163                  if(Dvalue < min_Dvalue)
   \                     ??i2c_init_3: (+1)
   \   0000008E   0xB280             UXTH     R0,R0
   \   00000090   0xB2A4             UXTH     R4,R4
   \   00000092   0x42A0             CMP      R0,R4
   \   00000094   0xD201             BCS      ??i2c_init_2
    164                  {
    165                      icr = n;
   \   00000096   0x0037             MOVS     R7,R6
    166                      min_Dvalue = Dvalue;
   \   00000098   0x0004             MOVS     R4,R0
    167                  }
   \                     ??i2c_init_2: (+1)
   \   0000009A   0xB2F6             UXTB     R6,R6
   \   0000009C   0x2E00             CMP      R6,#+0
   \   0000009E   0xD00D             BEQ      ??i2c_init_4
   \   000000A0   0x1E76             SUBS     R6,R6,#+1
   \   000000A2   0xB2AD             UXTH     R5,R5
   \   000000A4   0xA801             ADD      R0,SP,#+4
   \   000000A6   0xB2F6             UXTB     R6,R6
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0x4371             MULS     R1,R6,R1
   \   000000AC   0x5A40             LDRH     R0,[R0, R1]
   \   000000AE   0x1A28             SUBS     R0,R5,R0
   \   000000B0   0x.... 0x....      BL       abs
   \   000000B4   0xB280             UXTH     R0,R0
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD1E9             BNE      ??i2c_init_3
   \   000000BA   0x0037             MOVS     R7,R6
    168              }
    169          
    170              I2CN[i2cn]->F  = I2C_F_MULT(mult) | I2C_F_ICR(icr);     // I2C分频寄存器
   \                     ??i2c_init_4: (+1)
   \   000000BC   0x4668             MOV      R0,SP
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x0180             LSLS     R0,R0,#+6
   \   000000C2   0x06B9             LSLS     R1,R7,#+26       ;; ZeroExtS R1,R7,#+26,#+26
   \   000000C4   0x0E89             LSRS     R1,R1,#+26
   \   000000C6   0x4301             ORRS     R1,R1,R0
   \   000000C8   0x....             LDR      R0,??DataTable2
   \   000000CA   0xAA22             ADD      R2,SP,#+136
   \   000000CC   0x7812             LDRB     R2,[R2, #+0]
   \   000000CE   0x2304             MOVS     R3,#+4
   \   000000D0   0x435A             MULS     R2,R3,R2
   \   000000D2   0x5880             LDR      R0,[R0, R2]
   \   000000D4   0x7041             STRB     R1,[R0, #+1]
    171          
    172              // 使能 I2C
    173              I2CN[i2cn]->C1 = ( 0
    174                                 | I2C_C1_IICEN_MASK       //使能I2C
    175                                 //| I2C_C1_IICIE_MASK       //使能中断
    176                               );
   \   000000D6   0x2080             MOVS     R0,#+128
   \   000000D8   0x....             LDR      R1,??DataTable2
   \   000000DA   0xAA22             ADD      R2,SP,#+136
   \   000000DC   0x7812             LDRB     R2,[R2, #+0]
   \   000000DE   0x2304             MOVS     R3,#+4
   \   000000E0   0x435A             MULS     R2,R3,R2
   \   000000E2   0x5889             LDR      R1,[R1, R2]
   \   000000E4   0x7088             STRB     R0,[R1, #+2]
    177          
    178              return (  bus_clk_khz * 1000 / ( (1<<mult) * ICR_2_SCL_divider[icr])  );
   \   000000E6   0x....             LDR      R0,??DataTable3_2
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x21FA             MOVS     R1,#+250
   \   000000EC   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   000000EE   0x4348             MULS     R0,R1,R0
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x466A             MOV      R2,SP
   \   000000F4   0x7812             LDRB     R2,[R2, #+0]
   \   000000F6   0x4091             LSLS     R1,R1,R2
   \   000000F8   0xAA01             ADD      R2,SP,#+4
   \   000000FA   0xB2FF             UXTB     R7,R7
   \   000000FC   0x2302             MOVS     R3,#+2
   \   000000FE   0x435F             MULS     R7,R3,R7
   \   00000100   0x5BD2             LDRH     R2,[R2, R7]
   \   00000102   0x4351             MULS     R1,R2,R1
   \   00000104   0x.... 0x....      BL       __aeabi_uidiv
   \   00000108   0xB023             ADD      SP,SP,#+140
   \   0000010A   0xBDF0             POP      {R4-R7,PC}       ;; return
    179          }
    180          
    181          //-------------------------------------------------------------------------------------------------------------------
    182          //  @brief      I2C通信结束后需要调用的函数函数
    183          //  @return     void
    184          //  @since      v2.0
    185          //  @note		如果通信失败，可尝试增大此延时值，确认是否延时导致的
    186          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    187          void i2c_delay(void)
    188          {
   \                     i2c_delay: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    189              volatile uint16 n = 150;     //注意，这个数据太小，会导致读取错误。
   \   00000002   0x2096             MOVS     R0,#+150
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    190          
    191              while(n--);
   \                     ??i2c_delay_0: (+1)
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x1E41             SUBS     R1,R0,#+1
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x8011             STRH     R1,[R2, #+0]
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1F7             BNE      ??i2c_delay_0
    192          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    193          
    194          //-------------------------------------------------------------------------------------------------------------------
    195          //  @brief      读取I2C设备指定地址寄存器的数据
    196          //  @param      i2cn        I2C模块(i2c0、i2c1)
    197          //  @param      SlaveID     从机地址(7位地址)
    198          //  @param      reg         从机寄存器地址
    199          //  @return                 读取的寄存器值
    200          //  @since      v2.0
    201          //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50);//读取0x50地址的数据，从机地址为0x2D
    202          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    203          uint8 i2c_read_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg)
    204          {
   \                     i2c_read_reg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    205          
    206              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    207              //地址是低七位
    208              uint8 result;
    209          
    210              i2c_Start(i2cn);                                    //发送启动信号
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4361             MULS     R1,R4,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x7880             LDRB     R0,[R0, #+2]
   \   00000014   0x2130             MOVS     R1,#+48
   \   00000016   0x4301             ORRS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable4
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x4362             MULS     R2,R4,R2
   \   00000020   0x5880             LDR      R0,[R0, R2]
   \   00000022   0x7081             STRB     R1,[R0, #+2]
    211          
    212              i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
   \   00000024   0x0068             LSLS     R0,R5,#+1
   \   00000026   0x....             LDR      R1,??DataTable4
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0x4362             MULS     R2,R4,R2
   \   0000002E   0x5889             LDR      R1,[R1, R2]
   \   00000030   0x7108             STRB     R0,[R1, #+4]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x.... 0x....      BL       i2c_Wait
    213          
    214              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003A   0x....             LDR      R0,??DataTable4
   \   0000003C   0xB2E4             UXTB     R4,R4
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x4361             MULS     R1,R4,R1
   \   00000042   0x5840             LDR      R0,[R0, R1]
   \   00000044   0x7106             STRB     R6,[R0, #+4]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       i2c_Wait
    215          
    216              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   0000004E   0x....             LDR      R0,??DataTable4
   \   00000050   0xB2E4             UXTB     R4,R4
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x4361             MULS     R1,R4,R1
   \   00000056   0x5840             LDR      R0,[R0, R1]
   \   00000058   0x7880             LDRB     R0,[R0, #+2]
   \   0000005A   0x2104             MOVS     R1,#+4
   \   0000005C   0x4301             ORRS     R1,R1,R0
   \   0000005E   0x....             LDR      R0,??DataTable4
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0x2204             MOVS     R2,#+4
   \   00000064   0x4362             MULS     R2,R4,R2
   \   00000066   0x5880             LDR      R0,[R0, R2]
   \   00000068   0x7081             STRB     R1,[R0, #+2]
    217          
    218              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   0000006A   0x0068             LSLS     R0,R5,#+1
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x4301             ORRS     R1,R1,R0
   \   00000070   0x....             LDR      R0,??DataTable4
   \   00000072   0xB2E4             UXTB     R4,R4
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x4362             MULS     R2,R4,R2
   \   00000078   0x5880             LDR      R0,[R0, R2]
   \   0000007A   0x7101             STRB     R1,[R0, #+4]
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x.... 0x....      BL       i2c_Wait
    219          
    220              i2c_PutinRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   00000084   0x....             LDR      R0,??DataTable4
   \   00000086   0xB2E4             UXTB     R4,R4
   \   00000088   0x2104             MOVS     R1,#+4
   \   0000008A   0x4361             MULS     R1,R4,R1
   \   0000008C   0x5840             LDR      R0,[R0, R1]
   \   0000008E   0x7880             LDRB     R0,[R0, #+2]
   \   00000090   0x21EF             MOVS     R1,#+239
   \   00000092   0x4001             ANDS     R1,R1,R0
   \   00000094   0x....             LDR      R0,??DataTable4
   \   00000096   0xB2E4             UXTB     R4,R4
   \   00000098   0x2204             MOVS     R2,#+4
   \   0000009A   0x4362             MULS     R2,R4,R2
   \   0000009C   0x5880             LDR      R0,[R0, R2]
   \   0000009E   0x7081             STRB     R1,[R0, #+2]
   \   000000A0   0x....             LDR      R0,??DataTable4
   \   000000A2   0xB2E4             UXTB     R4,R4
   \   000000A4   0x2104             MOVS     R1,#+4
   \   000000A6   0x4361             MULS     R1,R4,R1
   \   000000A8   0x5840             LDR      R0,[R0, R1]
   \   000000AA   0x7880             LDRB     R0,[R0, #+2]
   \   000000AC   0x2108             MOVS     R1,#+8
   \   000000AE   0x4301             ORRS     R1,R1,R0
   \   000000B0   0x....             LDR      R0,??DataTable4
   \   000000B2   0xB2E4             UXTB     R4,R4
   \   000000B4   0x2204             MOVS     R2,#+4
   \   000000B6   0x4362             MULS     R2,R4,R2
   \   000000B8   0x5880             LDR      R0,[R0, R2]
   \   000000BA   0x7081             STRB     R1,[R0, #+2]
    221              result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
   \   000000BC   0x....             LDR      R0,??DataTable4
   \   000000BE   0xB2E4             UXTB     R4,R4
   \   000000C0   0x2104             MOVS     R1,#+4
   \   000000C2   0x4361             MULS     R1,R4,R1
   \   000000C4   0x5840             LDR      R0,[R0, R1]
   \   000000C6   0x7905             LDRB     R5,[R0, #+4]
    222              i2c_Wait(i2cn);                                     //等待接收完成
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0xB2C0             UXTB     R0,R0
   \   000000CC   0x.... 0x....      BL       i2c_Wait
    223          
    224              i2c_Stop(i2cn);                                     //发送停止信号
   \   000000D0   0x....             LDR      R0,??DataTable4
   \   000000D2   0xB2E4             UXTB     R4,R4
   \   000000D4   0x2104             MOVS     R1,#+4
   \   000000D6   0x4361             MULS     R1,R4,R1
   \   000000D8   0x5840             LDR      R0,[R0, R1]
   \   000000DA   0x7880             LDRB     R0,[R0, #+2]
   \   000000DC   0x21CF             MOVS     R1,#+207
   \   000000DE   0x4001             ANDS     R1,R1,R0
   \   000000E0   0x....             LDR      R0,??DataTable4
   \   000000E2   0xB2E4             UXTB     R4,R4
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0x4362             MULS     R2,R4,R2
   \   000000E8   0x5880             LDR      R0,[R0, R2]
   \   000000EA   0x7081             STRB     R1,[R0, #+2]
    225          
    226              result = I2CN[i2cn]->D;                             //读取数据
   \   000000EC   0x....             LDR      R0,??DataTable4
   \   000000EE   0xB2E4             UXTB     R4,R4
   \   000000F0   0x2104             MOVS     R1,#+4
   \   000000F2   0x434C             MULS     R4,R1,R4
   \   000000F4   0x5900             LDR      R0,[R0, R4]
   \   000000F6   0x7905             LDRB     R5,[R0, #+4]
    227          
    228              i2c_delay();                                        //必须延时一下，否则出错
   \   000000F8   0x.... 0x....      BL       i2c_delay
    229          
    230              return result;
   \   000000FC   0x0028             MOVS     R0,R5
   \   000000FE   0xB2C0             UXTB     R0,R0
   \   00000100   0xBD70             POP      {R4-R6,PC}       ;; return
    231          }
    232          
    233          //-------------------------------------------------------------------------------------------------------------------
    234          //  @brief      读取I2C设备指定地址寄存器的数据
    235          //  @param      i2cn        I2C模块(i2c0、i2c1)
    236          //  @param      SlaveID     从机地址(7位地址)
    237          //  @param      reg         从机寄存器地址
    238          //  @param      num         读取字节数
    239          //  @param      addr        读取的数据存储的地址
    240          //  @return     void
    241          //  @since      v2.0
    242          //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50, 10, buf);//读取0x50地址的数据，从机地址为0x2D开始的10个字节
    243          //-------------------------------------------------------------------------------------------------------------------
    244          

   \                                 In section .text, align 2, keep-with-next
    245          uint8 i2c_read_reg_bytes(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 num, uint8 * addr)
    246          {
   \                     i2c_read_reg_bytes: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    247              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    248              //地址是低七位
    249              uint8 result;
    250          
    251              i2c_Start(i2cn);                                    //发送启动信号
   \   0000000A   0x....             LDR      R0,??DataTable4
   \   0000000C   0xB2E4             UXTB     R4,R4
   \   0000000E   0x2104             MOVS     R1,#+4
   \   00000010   0x4361             MULS     R1,R4,R1
   \   00000012   0x5840             LDR      R0,[R0, R1]
   \   00000014   0x7881             LDRB     R1,[R0, #+2]
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0x....             LDR      R1,??DataTable4
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0x4362             MULS     R2,R4,R2
   \   00000022   0x5889             LDR      R1,[R1, R2]
   \   00000024   0x7088             STRB     R0,[R1, #+2]
    252          
    253              i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
   \   00000026   0x0078             LSLS     R0,R7,#+1
   \   00000028   0x....             LDR      R1,??DataTable4
   \   0000002A   0xB2E4             UXTB     R4,R4
   \   0000002C   0x2204             MOVS     R2,#+4
   \   0000002E   0x4362             MULS     R2,R4,R2
   \   00000030   0x5889             LDR      R1,[R1, R2]
   \   00000032   0x7108             STRB     R0,[R1, #+4]
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x.... 0x....      BL       i2c_Wait
    254          
    255              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003C   0x....             LDR      R0,??DataTable4
   \   0000003E   0xB2E4             UXTB     R4,R4
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x4361             MULS     R1,R4,R1
   \   00000044   0x5840             LDR      R0,[R0, R1]
   \   00000046   0x7105             STRB     R5,[R0, #+4]
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB2C0             UXTB     R0,R0
   \   0000004C   0x.... 0x....      BL       i2c_Wait
    256          
    257              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   00000050   0x....             LDR      R0,??DataTable4
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0x2104             MOVS     R1,#+4
   \   00000056   0x4361             MULS     R1,R4,R1
   \   00000058   0x5840             LDR      R0,[R0, R1]
   \   0000005A   0x7880             LDRB     R0,[R0, #+2]
   \   0000005C   0x2104             MOVS     R1,#+4
   \   0000005E   0x4301             ORRS     R1,R1,R0
   \   00000060   0x....             LDR      R0,??DataTable4
   \   00000062   0xB2E4             UXTB     R4,R4
   \   00000064   0x2204             MOVS     R2,#+4
   \   00000066   0x4362             MULS     R2,R4,R2
   \   00000068   0x5880             LDR      R0,[R0, R2]
   \   0000006A   0x7081             STRB     R1,[R0, #+2]
    258          
    259              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   0000006C   0x0078             LSLS     R0,R7,#+1
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x4301             ORRS     R1,R1,R0
   \   00000072   0x....             LDR      R0,??DataTable4
   \   00000074   0xB2E4             UXTB     R4,R4
   \   00000076   0x2204             MOVS     R2,#+4
   \   00000078   0x4362             MULS     R2,R4,R2
   \   0000007A   0x5880             LDR      R0,[R0, R2]
   \   0000007C   0x7101             STRB     R1,[R0, #+4]
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xB2C0             UXTB     R0,R0
   \   00000082   0x.... 0x....      BL       i2c_Wait
    260          
    261              i2c_EnterRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   00000086   0x....             LDR      R0,??DataTable4
   \   00000088   0xB2E4             UXTB     R4,R4
   \   0000008A   0x2104             MOVS     R1,#+4
   \   0000008C   0x4361             MULS     R1,R4,R1
   \   0000008E   0x5840             LDR      R0,[R0, R1]
   \   00000090   0x7880             LDRB     R0,[R0, #+2]
   \   00000092   0x21E7             MOVS     R1,#+231
   \   00000094   0x4001             ANDS     R1,R1,R0
   \   00000096   0x....             LDR      R0,??DataTable4
   \   00000098   0xB2E4             UXTB     R4,R4
   \   0000009A   0x2204             MOVS     R2,#+4
   \   0000009C   0x4362             MULS     R2,R4,R2
   \   0000009E   0x5880             LDR      R0,[R0, R2]
   \   000000A0   0x7081             STRB     R1,[R0, #+2]
   \   000000A2   0x9D06             LDR      R5,[SP, #+24]
   \   000000A4   0xE013             B        ??i2c_read_reg_bytes_0
    262          
    263              while(num--)
    264              {
    265                  result = I2CN[i2cn]->D;                         //虚假读取一次，启动接收数据
   \                     ??i2c_read_reg_bytes_1: (+1)
   \   000000A6   0x....             LDR      R0,??DataTable4
   \   000000A8   0xB2E4             UXTB     R4,R4
   \   000000AA   0x2104             MOVS     R1,#+4
   \   000000AC   0x4361             MULS     R1,R4,R1
   \   000000AE   0x5840             LDR      R0,[R0, R1]
   \   000000B0   0x7907             LDRB     R7,[R0, #+4]
    266                  i2c_Wait(i2cn);                                 //等待接收完成
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0xB2C0             UXTB     R0,R0
   \   000000B6   0x.... 0x....      BL       i2c_Wait
    267                  *addr = I2CN[i2cn]->D;                         //读取数据
   \   000000BA   0x....             LDR      R0,??DataTable4
   \   000000BC   0xB2E4             UXTB     R4,R4
   \   000000BE   0x2104             MOVS     R1,#+4
   \   000000C0   0x4361             MULS     R1,R4,R1
   \   000000C2   0x5840             LDR      R0,[R0, R1]
   \   000000C4   0x7900             LDRB     R0,[R0, #+4]
   \   000000C6   0x7028             STRB     R0,[R5, #+0]
    268                  i2c_delay();                                    //必须延时一下，否则出错
   \   000000C8   0x.... 0x....      BL       i2c_delay
    269                  addr++;
   \   000000CC   0x1C6D             ADDS     R5,R5,#+1
    270              }
   \                     ??i2c_read_reg_bytes_0: (+1)
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0x1E46             SUBS     R6,R0,#+1
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD1E6             BNE      ??i2c_read_reg_bytes_1
    271              i2c_DisableAck(i2cn);
   \   000000D8   0x....             LDR      R0,??DataTable4
   \   000000DA   0xB2E4             UXTB     R4,R4
   \   000000DC   0x2104             MOVS     R1,#+4
   \   000000DE   0x4361             MULS     R1,R4,R1
   \   000000E0   0x5840             LDR      R0,[R0, R1]
   \   000000E2   0x7880             LDRB     R0,[R0, #+2]
   \   000000E4   0x2108             MOVS     R1,#+8
   \   000000E6   0x4301             ORRS     R1,R1,R0
   \   000000E8   0x....             LDR      R0,??DataTable4
   \   000000EA   0xB2E4             UXTB     R4,R4
   \   000000EC   0x2204             MOVS     R2,#+4
   \   000000EE   0x4362             MULS     R2,R4,R2
   \   000000F0   0x5880             LDR      R0,[R0, R2]
   \   000000F2   0x7081             STRB     R1,[R0, #+2]
    272              i2c_PutinRxMode(i2cn);
   \   000000F4   0x....             LDR      R0,??DataTable4
   \   000000F6   0xB2E4             UXTB     R4,R4
   \   000000F8   0x2104             MOVS     R1,#+4
   \   000000FA   0x4361             MULS     R1,R4,R1
   \   000000FC   0x5840             LDR      R0,[R0, R1]
   \   000000FE   0x7880             LDRB     R0,[R0, #+2]
   \   00000100   0x21EF             MOVS     R1,#+239
   \   00000102   0x4001             ANDS     R1,R1,R0
   \   00000104   0x....             LDR      R0,??DataTable4
   \   00000106   0xB2E4             UXTB     R4,R4
   \   00000108   0x2204             MOVS     R2,#+4
   \   0000010A   0x4362             MULS     R2,R4,R2
   \   0000010C   0x5880             LDR      R0,[R0, R2]
   \   0000010E   0x7081             STRB     R1,[R0, #+2]
   \   00000110   0x....             LDR      R0,??DataTable4
   \   00000112   0xB2E4             UXTB     R4,R4
   \   00000114   0x2104             MOVS     R1,#+4
   \   00000116   0x4361             MULS     R1,R4,R1
   \   00000118   0x5840             LDR      R0,[R0, R1]
   \   0000011A   0x7880             LDRB     R0,[R0, #+2]
   \   0000011C   0x2108             MOVS     R1,#+8
   \   0000011E   0x4301             ORRS     R1,R1,R0
   \   00000120   0x....             LDR      R0,??DataTable4
   \   00000122   0xB2E4             UXTB     R4,R4
   \   00000124   0x2204             MOVS     R2,#+4
   \   00000126   0x4362             MULS     R2,R4,R2
   \   00000128   0x5880             LDR      R0,[R0, R2]
   \   0000012A   0x7081             STRB     R1,[R0, #+2]
    273              result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
   \   0000012C   0x....             LDR      R0,??DataTable4
   \   0000012E   0xB2E4             UXTB     R4,R4
   \   00000130   0x2104             MOVS     R1,#+4
   \   00000132   0x4361             MULS     R1,R4,R1
   \   00000134   0x5840             LDR      R0,[R0, R1]
   \   00000136   0x7907             LDRB     R7,[R0, #+4]
    274              i2c_Wait(i2cn);                                     //等待接收完成
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0xB2C0             UXTB     R0,R0
   \   0000013C   0x.... 0x....      BL       i2c_Wait
    275              i2c_Stop(i2cn);                                     //发送停止信号
   \   00000140   0x....             LDR      R0,??DataTable4
   \   00000142   0xB2E4             UXTB     R4,R4
   \   00000144   0x2104             MOVS     R1,#+4
   \   00000146   0x4361             MULS     R1,R4,R1
   \   00000148   0x5840             LDR      R0,[R0, R1]
   \   0000014A   0x7880             LDRB     R0,[R0, #+2]
   \   0000014C   0x21CF             MOVS     R1,#+207
   \   0000014E   0x4001             ANDS     R1,R1,R0
   \   00000150   0x....             LDR      R0,??DataTable4
   \   00000152   0xB2E4             UXTB     R4,R4
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0x4362             MULS     R2,R4,R2
   \   00000158   0x5880             LDR      R0,[R0, R2]
   \   0000015A   0x7081             STRB     R1,[R0, #+2]
    276              *addr = I2CN[i2cn]->D;                              //读取数据
   \   0000015C   0x....             LDR      R0,??DataTable4
   \   0000015E   0xB2E4             UXTB     R4,R4
   \   00000160   0x2104             MOVS     R1,#+4
   \   00000162   0x434C             MULS     R4,R1,R4
   \   00000164   0x5900             LDR      R0,[R0, R4]
   \   00000166   0x7900             LDRB     R0,[R0, #+4]
   \   00000168   0x7028             STRB     R0,[R5, #+0]
    277          
    278              i2c_delay();                                        //必须延时一下，否则出错
   \   0000016A   0x.... 0x....      BL       i2c_delay
    279          
    280              return result;
   \   0000016E   0x0038             MOVS     R0,R7
   \   00000170   0xB2C0             UXTB     R0,R0
   \   00000172   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    281          }
    282          
    283          //-------------------------------------------------------------------------------------------------------------------
    284          //  @brief      写入一个字节数据到I2C设备指定寄存器地址
    285          //  @param      i2cn        I2C模块(i2c0、i2c1)
    286          //  @param      SlaveID     从机地址(7位地址)
    287          //  @param      reg         从机寄存器地址
    288          //  @param      Data        数据
    289          //  @return     void
    290          //  @since      v2.0
    291          //  Sample usage:       	i2c_write_reg(i2c0, 0x2D, 0x50,2);     //写入数据2到0x50地址，从机地址为0x2D
    292          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    293          void i2c_write_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 Data)
    294          {
   \                     i2c_write_reg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001E             MOVS     R6,R3
    295          
    296              i2c_Start(i2cn);                                    //发送启动信号
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x4362             MULS     R2,R4,R2
   \   00000010   0x5880             LDR      R0,[R0, R2]
   \   00000012   0x7882             LDRB     R2,[R0, #+2]
   \   00000014   0x2030             MOVS     R0,#+48
   \   00000016   0x4310             ORRS     R0,R0,R2
   \   00000018   0x....             LDR      R2,??DataTable4
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x2304             MOVS     R3,#+4
   \   0000001E   0x4363             MULS     R3,R4,R3
   \   00000020   0x58D2             LDR      R2,[R2, R3]
   \   00000022   0x7090             STRB     R0,[R2, #+2]
    297          
    298              i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
   \   00000024   0x0048             LSLS     R0,R1,#+1
   \   00000026   0x....             LDR      R1,??DataTable4
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0x4362             MULS     R2,R4,R2
   \   0000002E   0x5889             LDR      R1,[R1, R2]
   \   00000030   0x7108             STRB     R0,[R1, #+4]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x.... 0x....      BL       i2c_Wait
    299          
    300              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003A   0x....             LDR      R0,??DataTable4
   \   0000003C   0xB2E4             UXTB     R4,R4
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x4361             MULS     R1,R4,R1
   \   00000042   0x5840             LDR      R0,[R0, R1]
   \   00000044   0x7105             STRB     R5,[R0, #+4]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       i2c_Wait
    301          
    302              i2c_write_byte(i2cn, Data);                         //发送需要写入的数据
   \   0000004E   0x....             LDR      R0,??DataTable4
   \   00000050   0xB2E4             UXTB     R4,R4
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x4361             MULS     R1,R4,R1
   \   00000056   0x5840             LDR      R0,[R0, R1]
   \   00000058   0x7106             STRB     R6,[R0, #+4]
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xB2C0             UXTB     R0,R0
   \   0000005E   0x.... 0x....      BL       i2c_Wait
    303          
    304              i2c_Stop(i2cn);
   \   00000062   0x....             LDR      R0,??DataTable4
   \   00000064   0xB2E4             UXTB     R4,R4
   \   00000066   0x2104             MOVS     R1,#+4
   \   00000068   0x4361             MULS     R1,R4,R1
   \   0000006A   0x5840             LDR      R0,[R0, R1]
   \   0000006C   0x7880             LDRB     R0,[R0, #+2]
   \   0000006E   0x21CF             MOVS     R1,#+207
   \   00000070   0x4001             ANDS     R1,R1,R0
   \   00000072   0x....             LDR      R0,??DataTable4
   \   00000074   0xB2E4             UXTB     R4,R4
   \   00000076   0x2204             MOVS     R2,#+4
   \   00000078   0x4354             MULS     R4,R2,R4
   \   0000007A   0x5900             LDR      R0,[R0, R4]
   \   0000007C   0x7081             STRB     R1,[R0, #+2]
    305          
    306              i2c_delay();                                        //延时太短的话，可能写出错
   \   0000007E   0x.... 0x....      BL       i2c_delay
    307          }
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40048014         DC32     0x40048014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0xFFFEFFFF         DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0xFFFDFFFF         DC32     0xfffdffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4004800C         DC32     0x4004800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40048010         DC32     0x40048010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0014 0x0016      DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
   \              0x0018 0x001A
   \              0x001C 0x001E
   \              0x0022 0x0028
   \              0x001C 0x0020
   \              0x0024 0x0028
   \              0x002C 0x0030
   \              0x0038 0x0044
   \              0x0030       
   \   00000022   0x0038 0x0040      DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
   \              0x0048 0x0050
   \              0x0058 0x0068
   \              0x0080 0x0050
   \              0x0060 0x0070
   \              0x0080 0x0090
   \              0x00A0 0x00C0
   \              0x00F0       
   \   00000040   0x00A0 0x00C0      DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
   \              0x00E0 0x0100
   \              0x0120 0x0140
   \              0x0180 0x01E0
   \              0x0140 0x0180
   \              0x01C0 0x0200
   \              0x0240       
   \   0000005A   0x0280 0x0300      DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
   \              0x03C0 0x0280
   \              0x0300 0x0380
   \              0x0400 0x0480
   \              0x0500 0x0600
   \              0x0780 0x0500
   \   00000072   0x0600 0x0700      DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840
   \              0x0800 0x0900
   \              0x0A00 0x0C00
   \              0x0F00       

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   i2c_Wait
         8   -> GpioSet
       8   i2c_delay
     160   i2c_init
       160   -> __aeabi_memcpy4
       160   -> abs
       160 __aeabi_uidiv
      16   i2c_read_reg
        16   -> i2c_Wait
        16   -> i2c_delay
      24   i2c_read_reg_bytes
        24   -> i2c_Wait
        24   -> i2c_delay
      16   i2c_write_reg
        16   -> i2c_Wait
        16   -> i2c_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable4
     128  ?_0
       8  I2CN
       1  MasterTransmission
       1  SlaveID
     168  i2c_Wait
      26  i2c_delay
     268  i2c_init
     258  i2c_read_reg
     372  i2c_read_reg_bytes
     132  i2c_write_reg

 
     2 bytes in section .bss
     8 bytes in section .data
   128 bytes in section .rodata
 1 264 bytes in section .text
 
 1 264 bytes of CODE  memory
   128 bytes of CONST memory
    10 bytes of DATA  memory

Errors: none
Warnings: none
