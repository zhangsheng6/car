###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        28/Sep/2018  18:58:04
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_uart.c
#    Command line =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_uart.c -D IAR -D
#        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -D DA_OLED -lCN
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\ -lB
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\ -o
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        F:\IAR安装包\arm\INC\c\DLib_Config_Normal.h -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\device\H\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\user\H\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\system\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\lib\H\ -I
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\..\system\coreSupport\
#        -Ol
#    List file    =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\List\KEA128_uart.lst
#    Object file  =  
#        I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\iar\KEA_128_FLASH\Obj\KEA128_uart.o
#
###############################################################################

I:\电磁程序-ZS\电磁直立-ZS\stand_ZS_9.28\lib\C\KEA128_uart.c
      1          /*********************************************************************************************************************
      2           * COPYRIGHT NOTICE
      3           * Copyright (c) 2017,逐飞科技
      4           * All rights reserved.
      5           * 技术讨论QQ群：179029047
      6           *
      7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
      8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
      9           *
     10           * @file       		KEA128_uart
     11           * @company	   		成都逐飞科技有限公司
     12           * @author     		逐飞科技(QQ3184284598)
     13           * @version    		v2.0
     14           * @Software 		IAR 7.7 or MDK 5.23
     15           * @Target core		S9KEA128AMLK
     16           * @Taobao   		https://seekfree.taobao.com/
     17           * @date       		2017-11-6
     18           ********************************************************************************************************************/
     19          
     20          
     21          #include "KEA128_uart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable9  ;; 0xe000e100
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable9_1  ;; 0xe000e180
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return
     22          
     23          
     24          

   \                                 In section .data, align 4
     25          UART_Type * uart[3] = UART_BASES;
   \                     uart:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H
   \              0x4006B000   
   \              0x4006C000   
     26          
     27          
     28          /**
     29            * 简介
     30            *     使能串口时钟，引脚复用
     31            */

   \                                 In section .text, align 2, keep-with-next
     32          void uart_mux(UARTn uartn)
     33          {
   \                     uart_mux: (+1)
   \   00000000   0xB500             PUSH     {LR}
     34              switch(uartn)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ      ??uart_mux_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD01E             BEQ      ??uart_mux_1
   \   0000000C   0xD30E             BCC      ??uart_mux_2
   \   0000000E   0xE02A             B        ??uart_mux_3
     35              {
     36                case uart0:
     37                  SIM->SCGC |= SIM_SCGC_UART0_MASK;               //使能串口0时钟
   \                     ??uart_mux_0: (+1)
   \   00000010   0x....             LDR      R0,??DataTable9_2  ;; 0x40048014
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2180             MOVS     R1,#+128
   \   00000016   0x0349             LSLS     R1,R1,#+13       ;; #+1048576
   \   00000018   0x4301             ORRS     R1,R1,R0
   \   0000001A   0x....             LDR      R0,??DataTable9_2  ;; 0x40048014
   \   0000001C   0x6001             STR      R1,[R0, #+0]
     38                  if(B0 == UART0_RX_PIN)
     39                  {
     40                      SIM->PINSEL &= ~SIM_PINSEL_UART0PS_MASK;
   \   0000001E   0x....             LDR      R0,??DataTable9_3  ;; 0x4004800c
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2180             MOVS     R1,#+128
   \   00000024   0x4388             BICS     R0,R0,R1
   \   00000026   0x....             LDR      R1,??DataTable9_3  ;; 0x4004800c
   \   00000028   0x6008             STR      R0,[R1, #+0]
     41                  }
     42                  else
     43                  {
     44                      SIM->PINSEL |= SIM_PINSEL_UART0PS_MASK;
     45                  }
     46                  break;
   \   0000002A   0xE01C             B        ??uart_mux_4
     47          
     48                case uart1:
     49                  SIM->SCGC |= SIM_SCGC_UART1_MASK;               //使能串口0时钟
   \                     ??uart_mux_2: (+1)
   \   0000002C   0x....             LDR      R0,??DataTable9_2  ;; 0x40048014
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x2180             MOVS     R1,#+128
   \   00000032   0x0389             LSLS     R1,R1,#+14       ;; #+2097152
   \   00000034   0x4301             ORRS     R1,R1,R0
   \   00000036   0x....             LDR      R0,??DataTable9_2  ;; 0x40048014
   \   00000038   0x6001             STR      R1,[R0, #+0]
     50                  if(C6 == UART1_RX_PIN)
     51                  {
     52                      SIM->PINSEL1 &= ~SIM_PINSEL1_UART1PS_MASK;
     53                  }
     54                  else
     55                  {
     56                      SIM->PINSEL1 |= SIM_PINSEL1_UART1PS_MASK;
   \   0000003A   0x....             LDR      R0,??DataTable9_4  ;; 0x40048010
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2180             MOVS     R1,#+128
   \   00000040   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   00000042   0x4301             ORRS     R1,R1,R0
   \   00000044   0x....             LDR      R0,??DataTable9_4  ;; 0x40048010
   \   00000046   0x6001             STR      R1,[R0, #+0]
     57                  }
     58                  break;
   \   00000048   0xE00D             B        ??uart_mux_4
     59          
     60                case uart2:
     61                  SIM->SCGC |= SIM_SCGC_UART2_MASK;               //使能串口0时钟
   \                     ??uart_mux_1: (+1)
   \   0000004A   0x....             LDR      R0,??DataTable9_2  ;; 0x40048014
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x2180             MOVS     R1,#+128
   \   00000050   0x03C9             LSLS     R1,R1,#+15       ;; #+4194304
   \   00000052   0x4301             ORRS     R1,R1,R0
   \   00000054   0x....             LDR      R0,??DataTable9_2  ;; 0x40048014
   \   00000056   0x6001             STR      R1,[R0, #+0]
     62                  if(D6 == UART2_RX_PIN)
     63                  {
     64                      SIM->PINSEL1 &= ~SIM_PINSEL1_UART2PS_MASK;
   \   00000058   0x....             LDR      R0,??DataTable9_4  ;; 0x40048010
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x....             LDR      R1,??DataTable9_5  ;; 0xffffdfff
   \   0000005E   0x4001             ANDS     R1,R1,R0
   \   00000060   0x....             LDR      R0,??DataTable9_4  ;; 0x40048010
   \   00000062   0x6001             STR      R1,[R0, #+0]
     65                  }
     66                  else
     67                  {
     68                      SIM->PINSEL1 |= SIM_PINSEL1_UART2PS_MASK;
     69                  }
     70                  break;
   \   00000064   0xE7FF             B        ??uart_mux_4
     71                default :
     72                  break;
     73          
     74              }
     75          }
   \                     ??uart_mux_3: (+1)
   \                     ??uart_mux_4: (+1)
   \   00000066   0xBD00             POP      {PC}             ;; return
     76          
     77          //-------------------------------------------------------------------------------------------------------------------
     78          //  @brief      uart 初始化
     79          //  @param      uartn           选择串口(uart0,uart1,uart2)
     80          //  @param      baud            串口波特率
     81          //  @return     uint32          实际设置得波特率
     82          //  @since      v1.0
     83          //  Sample usage:               uart_init(uart1,9600);   //初始化串口1为1位起始位、8位数据位、1位停止位、波特率9600
     84          //  @note                       由于KEA128没有波特率微调寄存器，因此在设置得波特率较高得情况下误差比较大，因此返回实际波特率用来校验
     85          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     86          uint32 UART_Init(UARTn uartn, uint32 baud)
     87          {
   \                     UART_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     88              vuint32 uart_input_clk;
     89              uint32 sbr;
     90          
     91              uart_mux(uartn);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x.... 0x....      BL       uart_mux
     92          
     93              //设置的时候，应该禁止发送和接收
     94              uart[uartn]->C2 &= ~(0
     95                                   | UART_C2_TE_MASK
     96                                   | UART_C2_RE_MASK);
   \   0000000E   0x....             LDR      R0,??DataTable9_6
   \   00000010   0xB2E4             UXTB     R4,R4
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x4361             MULS     R1,R4,R1
   \   00000016   0x5840             LDR      R0,[R0, R1]
   \   00000018   0x78C0             LDRB     R0,[R0, #+3]
   \   0000001A   0x21F3             MOVS     R1,#+243
   \   0000001C   0x4001             ANDS     R1,R1,R0
   \   0000001E   0x....             LDR      R0,??DataTable9_6
   \   00000020   0xB2E4             UXTB     R4,R4
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4362             MULS     R2,R4,R2
   \   00000026   0x5880             LDR      R0,[R0, R2]
   \   00000028   0x70C1             STRB     R1,[R0, #+3]
     97          
     98              //配置成8位无校验模式
     99              //设置 UART 数据格式、校验方式和停止位位数。通过设置 UART 模块控制寄存器 C1 实现；
    100              uart[uartn]->C1 |= (0
    101                                  //| UART_C1_M_MASK                      //9 位或 8 位模式选择 : 0 为 8位 ，1 为 9位（注释了表示0，即8位） （如果是9位，位8在UARTx_C3里）
    102                                  //| UART_C1_PE_MASK                     //奇偶校验使能（注释了表示禁用）
    103                                  //| UART_C1_PT_MASK                     //校验位类型 : 0 为 偶校验 ，1 为 奇校验
    104                                 );
   \   0000002A   0x....             LDR      R0,??DataTable9_6
   \   0000002C   0xB2E4             UXTB     R4,R4
   \   0000002E   0x2104             MOVS     R1,#+4
   \   00000030   0x4361             MULS     R1,R4,R1
   \   00000032   0x5840             LDR      R0,[R0, R1]
   \   00000034   0x7880             LDRB     R0,[R0, #+2]
   \   00000036   0x....             LDR      R1,??DataTable9_6
   \   00000038   0xB2E4             UXTB     R4,R4
   \   0000003A   0x2204             MOVS     R2,#+4
   \   0000003C   0x4362             MULS     R2,R4,R2
   \   0000003E   0x5889             LDR      R1,[R1, R2]
   \   00000040   0x7088             STRB     R0,[R1, #+2]
    105          
    106              //计算波特率
    107              uart_input_clk = bus_clk_khz * 1000;   //bus时钟
   \   00000042   0x....             LDR      R0,??DataTable9_7
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x21FA             MOVS     R1,#+250
   \   00000048   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   0000004A   0x4348             MULS     R0,R1,R0
   \   0000004C   0x9000             STR      R0,[SP, #+0]
    108          
    109              //UART 波特率 = UART 模块时钟 / (16 × SBR[12:0])
    110              //SBR = UART 模块时钟 / (16 * UART 波特率)
    111              sbr = uart_input_clk / (16 * baud); //设置误差要在 0.04以内，否则会不稳定，最大16384
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x2110             MOVS     R1,#+16
   \   00000052   0x434D             MULS     R5,R1,R5
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x.... 0x....      BL       __aeabi_uidiv
   \   0000005A   0x0001             MOVS     R1,R0
    112              sbr += 1;/* 115200的abr=21.7,0.04误差是0.808，所以将sbr设置为22,减小误差 */
   \   0000005C   0x1C49             ADDS     R1,R1,#+1
    113          //    sbr = ((uart_input_clk>>4)*10 / baud + 5)/10;               //四舍五入
    114          //    if(sbr > 0x1FFF)sbr = 0x1FFF;                               //SBR 是 13bit，最大为 0x1FFF
    115          
    116              //写 SBR
    117              uart[uartn]->BDH &= ~UART_BDH_SBR_MASK;                     //清除原来波特率
   \   0000005E   0x....             LDR      R0,??DataTable9_6
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0x2204             MOVS     R2,#+4
   \   00000064   0x4362             MULS     R2,R4,R2
   \   00000066   0x5880             LDR      R0,[R0, R2]
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x22E0             MOVS     R2,#+224
   \   0000006C   0x4002             ANDS     R2,R2,R0
   \   0000006E   0x....             LDR      R0,??DataTable9_6
   \   00000070   0xB2E4             UXTB     R4,R4
   \   00000072   0x2304             MOVS     R3,#+4
   \   00000074   0x4363             MULS     R3,R4,R3
   \   00000076   0x58C0             LDR      R0,[R0, R3]
   \   00000078   0x7002             STRB     R2,[R0, #+0]
    118              uart[uartn]->BDH |= UART_BDH_SBR(sbr>>8);                   //先写入SBR高位
   \   0000007A   0x....             LDR      R0,??DataTable9_6
   \   0000007C   0xB2E4             UXTB     R4,R4
   \   0000007E   0x2204             MOVS     R2,#+4
   \   00000080   0x4362             MULS     R2,R4,R2
   \   00000082   0x5880             LDR      R0,[R0, R2]
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x000A             MOVS     R2,R1
   \   00000088   0x0A12             LSRS     R2,R2,#+8
   \   0000008A   0x06D2             LSLS     R2,R2,#+27       ;; ZeroExtS R2,R2,#+27,#+27
   \   0000008C   0x0ED2             LSRS     R2,R2,#+27
   \   0000008E   0x4302             ORRS     R2,R2,R0
   \   00000090   0x....             LDR      R0,??DataTable9_6
   \   00000092   0xB2E4             UXTB     R4,R4
   \   00000094   0x2304             MOVS     R3,#+4
   \   00000096   0x4363             MULS     R3,R4,R3
   \   00000098   0x58C0             LDR      R0,[R0, R3]
   \   0000009A   0x7002             STRB     R2,[R0, #+0]
    119              uart[uartn]->BDL  = UART_BDL_SBR((uint8)sbr);               //再写入SBR低位
   \   0000009C   0x0008             MOVS     R0,R1
   \   0000009E   0x....             LDR      R2,??DataTable9_6
   \   000000A0   0xB2E4             UXTB     R4,R4
   \   000000A2   0x2304             MOVS     R3,#+4
   \   000000A4   0x4363             MULS     R3,R4,R3
   \   000000A6   0x58D2             LDR      R2,[R2, R3]
   \   000000A8   0x7050             STRB     R0,[R2, #+1]
    120          
    121              // 允许发送和接收
    122              uart[uartn]->C2 |= (0
    123                                  | UART_C2_TE_MASK                       //发送使能
    124                                  | UART_C2_RE_MASK                       //接收使能
    125                                  //| UART_C2_TIE_MASK                    //发送中断或DMA传输请求使能（注释了表示禁用）
    126                                  //| UART_C2_TCIE_MASK                   //发送完成中断使能（注释了表示禁用）
    127                                  //| UART_C2_RIE_MASK                    //接收满中断或DMA传输请求使能（注释了表示禁用）
    128                                  );
   \   000000AA   0x....             LDR      R0,??DataTable9_6
   \   000000AC   0xB2E4             UXTB     R4,R4
   \   000000AE   0x2204             MOVS     R2,#+4
   \   000000B0   0x4362             MULS     R2,R4,R2
   \   000000B2   0x5880             LDR      R0,[R0, R2]
   \   000000B4   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B6   0x220C             MOVS     R2,#+12
   \   000000B8   0x4302             ORRS     R2,R2,R0
   \   000000BA   0x....             LDR      R0,??DataTable9_6
   \   000000BC   0xB2E4             UXTB     R4,R4
   \   000000BE   0x2304             MOVS     R3,#+4
   \   000000C0   0x435C             MULS     R4,R3,R4
   \   000000C2   0x5900             LDR      R0,[R0, R4]
   \   000000C4   0x70C2             STRB     R2,[R0, #+3]
    129              //由于KEA128没有波特率微调寄存器，因此在设置得波特率较高得情况下误差比较大，因此返回实际波特率用来校验
    130              return ((uart_input_clk>>4)/sbr);                           //返回实际波特率
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x0900             LSRS     R0,R0,#+4
   \   000000CA   0x.... 0x....      BL       __aeabi_uidiv
   \   000000CE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    131          }
    132          
    133          //-------------------------------------------------------------------------------------------------------------------
    134          //  @brief      串口发送一个字节
    135          //  @param      uartn           选择串口
    136          //  @param      ch              要发送的字符
    137          //  @return     void
    138          //  @since      v1.0
    139          //  Sample usage:               uart_putchar(uart2,0x5a);
    140          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    141          void uart_putchar(UARTn uartn, uint8 ch)
    142          {
   \                     uart_putchar: (+1)
   \   00000000   0xB500             PUSH     {LR}
    143              while( !((uart[uartn]->S1) & UART_S1_TDRE_MASK) );  //等待发送缓冲区空
   \                     ??uart_putchar_0: (+1)
   \   00000002   0x....             LDR      R2,??DataTable9_6
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2304             MOVS     R3,#+4
   \   00000008   0x4343             MULS     R3,R0,R3
   \   0000000A   0x58D2             LDR      R2,[R2, R3]
   \   0000000C   0x7912             LDRB     R2,[R2, #+4]
   \   0000000E   0x0612             LSLS     R2,R2,#+24
   \   00000010   0xD5F7             BPL      ??uart_putchar_0
    144              uart[uartn]->D = (uint8)ch;                         //发送数据
   \   00000012   0x....             LDR      R2,??DataTable9_6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4358             MULS     R0,R3,R0
   \   0000001A   0x5810             LDR      R0,[R2, R0]
   \   0000001C   0x71C1             STRB     R1,[R0, #+7]
    145          }
   \   0000001E   0xBD00             POP      {PC}             ;; return
    146          
    147          //-------------------------------------------------------------------------------------------------------------------
    148          //  @brief      串口发送数组
    149          //  @param      uartn           选择串口
    150          //  @param      *buff           要发送的数组地址
    151          //  @param      len             发送长度
    152          //  @return     void
    153          //  @since      v1.0
    154          //  Sample usage:               uart_putbuff(uart2,&a[0],sizeof(a));
    155          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    156          void uart_putbuff (UARTn uartn, uint8 *buff, uint32 len)
    157          {
   \                     uart_putbuff: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0xE005             B        ??uart_putbuff_0
    158              while(len--)
    159              {
    160                  uart_putchar(uartn, *buff);
   \                     ??uart_putbuff_1: (+1)
   \   0000000A   0x7821             LDRB     R1,[R4, #+0]
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x.... 0x....      BL       uart_putchar
    161                  buff++;
   \   00000014   0x1C64             ADDS     R4,R4,#+1
    162              }
   \                     ??uart_putbuff_0: (+1)
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x1E45             SUBS     R5,R0,#+1
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F5             BNE      ??uart_putbuff_1
    163          }
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    164          
    165          //-------------------------------------------------------------------------------------------------------------------
    166          //  @brief      串口发送字符串
    167          //  @param      uartn           选择串口
    168          //  @param      *str            要发送的字符串地址
    169          //  @return     void
    170          //  @since      v1.0
    171          //  Sample usage:               uart_putstr(uart2,"i lvoe you");
    172          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    173          void uart_putstr (UARTn uartn, const uint8 *str)
    174          {
   \                     uart_putstr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0xE005             B        ??uart_putstr_0
    175              while(*str)
    176              {
    177                  uart_putchar(uartn, *str++);
   \                     ??uart_putstr_1: (+1)
   \   00000008   0x7829             LDRB     R1,[R5, #+0]
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x.... 0x....      BL       uart_putchar
   \   00000012   0x1C6D             ADDS     R5,R5,#+1
    178              }
   \                     ??uart_putstr_0: (+1)
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F6             BNE      ??uart_putstr_1
    179          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    180          
    181          //-------------------------------------------------------------------------------------------------------------------
    182          //  @brief      串口等待接收1个字符
    183          //  @param      uartn           选择串口
    184          //  @param      *str            接收的地址
    185          //  @return     void
    186          //  @since      v1.0
    187          //  Sample usage:               uart_getchar(uart2,&dat);
    188          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    189          void uart_getchar (UARTn uartn, uint8 *ch)
    190          {
   \                     uart_getchar: (+1)
   \   00000000   0xB500             PUSH     {LR}
    191              while(!(uart[uartn]->S1 & UART_S1_RDRF_MASK));  //等待接收满了
   \                     ??uart_getchar_0: (+1)
   \   00000002   0x....             LDR      R2,??DataTable9_6
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2304             MOVS     R3,#+4
   \   00000008   0x4343             MULS     R3,R0,R3
   \   0000000A   0x58D2             LDR      R2,[R2, R3]
   \   0000000C   0x7912             LDRB     R2,[R2, #+4]
   \   0000000E   0x0692             LSLS     R2,R2,#+26
   \   00000010   0xD5F7             BPL      ??uart_getchar_0
    192              *ch =  uart[uartn]->D;                          // 获取接收到的8位数据
   \   00000012   0x....             LDR      R2,??DataTable9_6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4358             MULS     R0,R3,R0
   \   0000001A   0x5810             LDR      R0,[R2, R0]
   \   0000001C   0x79C0             LDRB     R0,[R0, #+7]
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    193              // 获取 9位数据时ch 应该是uint16 *类型的否则数据会溢出：
    194              // *ch =   ((( UARTx_C3_REG(UARTN[uartn]) & UART_C3_R8_MASK ) >> UART_C3_R8_SHIFT ) << 8)   |   UART_D_REG(UARTN[uartn]);  //返回9bit
    195          }
   \   00000020   0xBD00             POP      {PC}             ;; return
    196          
    197          
    198          //-------------------------------------------------------------------------------------------------------------------
    199          //  @brief      开启接收中断
    200          //  @param      uartn           选择串口
    201          //  @return     void
    202          //  @since      v1.0
    203          //  Sample usage:               uart_rx_irq_en(uart2);
    204          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    205          void uart_rx_irq_en(UARTn uartn)
    206          {
   \                     uart_rx_irq_en: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    207              uart[uartn]->C2 |= UART_C2_RIE_MASK;                                        //使能UART接收中断
   \   00000002   0x....             LDR      R1,??DataTable9_6
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x5889             LDR      R1,[R1, R2]
   \   0000000C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000000E   0x2220             MOVS     R2,#+32
   \   00000010   0x430A             ORRS     R2,R2,R1
   \   00000012   0x....             LDR      R1,??DataTable9_6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4343             MULS     R3,R0,R3
   \   0000001A   0x58C9             LDR      R1,[R1, R3]
   \   0000001C   0x70CA             STRB     R2,[R1, #+3]
    208              enable_irq((IRQn_Type)((uint8)uartn + UART0_IRQn));                                //使能IRQ中断
   \   0000001E   0x300C             ADDS     R0,R0,#+12
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       NVIC_EnableIRQ
    209          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    210          
    211          //-------------------------------------------------------------------------------------------------------------------
    212          //  @brief      开启发送完成中断
    213          //  @param      uartn           选择串口
    214          //  @return     void
    215          //  @since      v1.0
    216          //  Sample usage:               uart_txc_irq_en(uart2);
    217          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    218          void uart_txc_irq_en(UARTn uartn)
    219          {
   \                     uart_txc_irq_en: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    220              uart[uartn]->C2 |= UART_C2_TCIE_MASK;                                       //使能UART发送完成中断
   \   00000002   0x....             LDR      R1,??DataTable9_6
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x5889             LDR      R1,[R1, R2]
   \   0000000C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000000E   0x2240             MOVS     R2,#+64
   \   00000010   0x430A             ORRS     R2,R2,R1
   \   00000012   0x....             LDR      R1,??DataTable9_6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4343             MULS     R3,R0,R3
   \   0000001A   0x58C9             LDR      R1,[R1, R3]
   \   0000001C   0x70CA             STRB     R2,[R1, #+3]
    221              enable_irq((IRQn_Type)((uint8)uartn + UART0_IRQn));                                //使能IRQ中断
   \   0000001E   0x300C             ADDS     R0,R0,#+12
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       NVIC_EnableIRQ
    222          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    223          
    224          //-------------------------------------------------------------------------------------------------------------------
    225          //  @brief      禁止接收中断
    226          //  @param      uartn           选择串口
    227          //  @return     void
    228          //  @since      v1.0
    229          //  Sample usage:               uart_rx_irq_dis(uart2);
    230          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    231          void uart_rx_irq_dis(UARTn uartn)
    232          {
   \                     uart_rx_irq_dis: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    233              uart[uartn]->C2 &= ~UART_C2_RIE_MASK;                                       //禁止UART接收中断
   \   00000002   0x....             LDR      R1,??DataTable9_6
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x5889             LDR      R1,[R1, R2]
   \   0000000C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000000E   0x22DF             MOVS     R2,#+223
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x....             LDR      R1,??DataTable9_6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4343             MULS     R3,R0,R3
   \   0000001A   0x58C9             LDR      R1,[R1, R3]
   \   0000001C   0x70CA             STRB     R2,[R1, #+3]
    234          
    235              //如果发送中断还没有关，则不关闭IRQ
    236              if(!(uart[uartn]->C2 & (UART_C2_TIE_MASK | UART_C2_TCIE_MASK)) )
   \   0000001E   0x....             LDR      R1,??DataTable9_6
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4342             MULS     R2,R0,R2
   \   00000026   0x5889             LDR      R1,[R1, R2]
   \   00000028   0x78C9             LDRB     R1,[R1, #+3]
   \   0000002A   0x22C0             MOVS     R2,#+192
   \   0000002C   0x4211             TST      R1,R2
   \   0000002E   0xD103             BNE      ??uart_rx_irq_dis_0
    237              {
    238                  disable_irq((IRQn_Type)((uint8)uartn + UART0_IRQn));                           //关IRQ中断
   \   00000030   0x300C             ADDS     R0,R0,#+12
   \   00000032   0xB240             SXTB     R0,R0
   \   00000034   0x.... 0x....      BL       NVIC_DisableIRQ
    239              }
    240          }
   \                     ??uart_rx_irq_dis_0: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    241          
    242          //-------------------------------------------------------------------------------------------------------------------
    243          //  @brief      禁止发送完成中断
    244          //  @param      uartn           选择串口
    245          //  @return     void
    246          //  @since      v1.0
    247          //  Sample usage:               uart_txc_irq_dis(uart2);
    248          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    249          void uart_txc_irq_dis(UARTn uartn)
    250          {
   \                     uart_txc_irq_dis: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    251              uart[uartn]->C2 &= ~UART_C2_TCIE_MASK;                                      //禁止UART发送完成中断
   \   00000002   0x....             LDR      R1,??DataTable9_6
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x5889             LDR      R1,[R1, R2]
   \   0000000C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000000E   0x22BF             MOVS     R2,#+191
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x....             LDR      R1,??DataTable9_6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4343             MULS     R3,R0,R3
   \   0000001A   0x58C9             LDR      R1,[R1, R3]
   \   0000001C   0x70CA             STRB     R2,[R1, #+3]
    252          
    253              //如果接收中断还没有关，则不关闭IRQ
    254              if(!(uart[uartn]->C2 & UART_C2_RIE_MASK) )
   \   0000001E   0x....             LDR      R1,??DataTable9_6
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4342             MULS     R2,R0,R2
   \   00000026   0x5889             LDR      R1,[R1, R2]
   \   00000028   0x78C9             LDRB     R1,[R1, #+3]
   \   0000002A   0x0689             LSLS     R1,R1,#+26
   \   0000002C   0xD403             BMI      ??uart_txc_irq_dis_0
    255              {
    256                  disable_irq((IRQn_Type)((uint8)uartn + UART0_IRQn));              //关IRQ中断
   \   0000002E   0x300C             ADDS     R0,R0,#+12
   \   00000030   0xB240             SXTB     R0,R0
   \   00000032   0x.... 0x....      BL       NVIC_DisableIRQ
    257              }
    258          }
   \                     ??uart_txc_irq_dis_0: (+1)
   \   00000036   0xBD01             POP      {R0,PC}          ;; return
    259          
    260          //串口中断函数请到isr.c文件参考
    261          
    262          
    263          
    264          //-------------------------------------------------------------------------------------------------------------------
    265          //  @brief      重定义printf 到串口
    266          //  @param      ch      需要打印的字节
    267          //  @param      stream  数据流
    268          //  @since      v1.0
    269          //  @note       此函数由编译器自带库里的printf所调用
    270          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    271          int fputc(int ch, FILE *stream)
    272          {
   \                     fputc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    273          //    uart_putchar(DEBUG_PORT, (char)ch);
    274              UART_Send_Byte((char)ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x.... 0x....      BL       UART_Send_Byte
    275              return(ch);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    276          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40048014         DC32     0x40048014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x4004800C         DC32     0x4004800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40048010         DC32     0x40048010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0xFFFFDFFF         DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     bus_clk_khz
    277          
    278          
    279          
    280          
    281          
    282          
    283          
    284          
    285          
    286          
    287          
    288          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
      16   UART_Init
        16   -> uart_mux
        16 __aeabi_uidiv
       8   fputc
         8   -> UART_Send_Byte
       4   uart_getchar
       4   uart_mux
      16   uart_putbuff
        16   -> uart_putchar
       4   uart_putchar
      16   uart_putstr
        16   -> uart_putchar
       8   uart_rx_irq_dis
         8   -> NVIC_DisableIRQ
       8   uart_rx_irq_en
         8   -> NVIC_EnableIRQ
       8   uart_txc_irq_dis
         8   -> NVIC_DisableIRQ
       8   uart_txc_irq_en
         8   -> NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
      14  NVIC_DisableIRQ
      14  NVIC_EnableIRQ
     208  UART_Init
      16  fputc
      12  uart
      34  uart_getchar
     104  uart_mux
      32  uart_putbuff
      32  uart_putchar
      28  uart_putstr
      58  uart_rx_irq_dis
      40  uart_rx_irq_en
      56  uart_txc_irq_dis
      40  uart_txc_irq_en

 
  12 bytes in section .data
 708 bytes in section .text
 
 708 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: none
