###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        01/May/2018  16:13:20
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  H:\智能车程序2018\电磁三轮――ZS\5.1\user\C\inductor_1.c
#    Command line =  
#        H:\智能车程序2018\电磁三轮――ZS\5.1\user\C\inductor_1.c -D IAR -D
#        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -lCN
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\List\ -lB
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\List\ -o
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None
#        --dlib_config F:\IAR安装包\arm\INC\c\DLib_Config_Normal.h -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\device\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\user\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\system\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\lib\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\system\coreSupport\ -On
#    List file    =  
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\List\inductor_1.lst
#    Object file  =  
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\Obj\inductor_1.o
#
###############################################################################

H:\智能车程序2018\电磁三轮――ZS\5.1\user\C\inductor_1.c
      1          #include "inductor_1.h"
      2          #include "Variable.h"
      3          #include "common.h"
      4          #include "allHead.h"
      5          
      6          
      7          
      8          //右  中 左   右竖 左竖 gnd
      9          //橙  红 褐    黑   白  黄
     10          //橙  黄 蓝    灰   紫  绿色
     11          //4   2  3    1    5
     12          //              右电感   中电感   左电感   位置     差值
     13          //右电感最大    490,97    250,50  16,1      1        -95
     14          //左电感最大    4,0.1    240,47  509,100    2         99
     15          //过左弯道时     40,7    312,62   287,57    2          50      
     16          //过左弯道时     4，0.1    194,38   287,57    2          50    
     17                                               //          范围
     18          //AD值：AD_valu[3]为采集到处理后的的AD值          0-260(小车行驶时)
     19          //归一值sensor_to_one[5]为将AD值归一化            0-1
     20          //最终值：AD_inductor[5]为将归一化的值放大100倍    0-100
     21          //丢线：信号很小了，然后就按照找不到信号线来处理
     22          //Position_transit[i]:记录过渡点归一化放大后的值
     23          //Position_transit[0]:右电感位于电磁线正上方时中电感归一化放大后的值
     24          //Position_transit[1]:左电感位于电磁线正上方时中电感归一化放大后的值
     25          //差值：差值大小由中电感与电磁线的相对位置决定
     26          //小车在赛道内差值为100以内，出半个赛道200左右，全出赛道300左右
     27          
     28          
     29          
     30          
     31          
     32          
     33          /*************************************************************************
     34           *  函数名称   Read_ADC
     35           *  功能说明： AD采集
     36           *  参数说明：
     37           *  函数返回： 无
     38           *  修改时间：
     39           *  备    注：
     40          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     41          void Read_ADC(void)
     42          {
   \                     Read_ADC: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     43                int16  i,j,k,temp;
     44                int16  ad_valu1[5],ad_sum[5];
     45          
     46                for(i=0;i<5;i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_0: (+1)
   \   00000008   0xB224             SXTH     R4,R4
   \   0000000A   0x2C05             CMP      R4,#+5
   \   0000000C   0xDA32             BGE      ??Read_ADC_1
     47                {
     48          
     49                      ad_valu[0][i] = ADC_Once(ADC_1,adc12bit);  //左  通道
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x202D             MOVS     R0,#+45
   \   00000012   0x.... 0x....      BL       ADC_Once
   \   00000016   0x....             LDR      R1,??DataTable1
   \   00000018   0xB224             SXTH     R4,R4
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x4362             MULS     R2,R4,R2
   \   0000001E   0x5288             STRH     R0,[R1, R2]
     50                      ad_valu[1][i] = ADC_Once(ADC_2,adc12bit);  //中  通道
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x2011             MOVS     R0,#+17
   \   00000024   0x.... 0x....      BL       ADC_Once
   \   00000028   0x....             LDR      R1,??DataTable1
   \   0000002A   0xB224             SXTH     R4,R4
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x4362             MULS     R2,R4,R2
   \   00000030   0x1889             ADDS     R1,R1,R2
   \   00000032   0x8148             STRH     R0,[R1, #+10]
     51                      ad_valu[2][i] = ADC_Once(ADC_3,adc12bit);  //右  通道
   \   00000034   0x2102             MOVS     R1,#+2
   \   00000036   0x202F             MOVS     R0,#+47
   \   00000038   0x.... 0x....      BL       ADC_Once
   \   0000003C   0x....             LDR      R1,??DataTable1
   \   0000003E   0xB224             SXTH     R4,R4
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0x4362             MULS     R2,R4,R2
   \   00000044   0x1889             ADDS     R1,R1,R2
   \   00000046   0x8288             STRH     R0,[R1, #+20]
     52                      ad_valu[3][i] = ADC_Once(ADC_4,adc12bit);  //中1 通道
   \   00000048   0x2102             MOVS     R1,#+2
   \   0000004A   0x2010             MOVS     R0,#+16
   \   0000004C   0x.... 0x....      BL       ADC_Once
   \   00000050   0x....             LDR      R1,??DataTable1
   \   00000052   0xB224             SXTH     R4,R4
   \   00000054   0x2202             MOVS     R2,#+2
   \   00000056   0x4362             MULS     R2,R4,R2
   \   00000058   0x1889             ADDS     R1,R1,R2
   \   0000005A   0x83C8             STRH     R0,[R1, #+30]
     53                      ad_valu[4][i] = ADC_Once(ADC_5,adc12bit);  //中2 通道
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x202C             MOVS     R0,#+44
   \   00000060   0x.... 0x....      BL       ADC_Once
   \   00000064   0x....             LDR      R1,??DataTable1
   \   00000066   0xB224             SXTH     R4,R4
   \   00000068   0x2202             MOVS     R2,#+2
   \   0000006A   0x4362             MULS     R2,R4,R2
   \   0000006C   0x1889             ADDS     R1,R1,R2
   \   0000006E   0x8508             STRH     R0,[R1, #+40]
     54                      
     55          //            if(ad_valu[0][i] > 650) ad_valu[0][i]=500;
     56          //            if(ad_valu[1][i] > 650) ad_valu[0][i]=500;
     57          //            if(ad_valu[2][i] > 650) ad_valu[0][i]=500;
     58          
     59                }
   \   00000070   0x1C64             ADDS     R4,R4,#+1
   \   00000072   0xE7C9             B        ??Read_ADC_0
     60             //////////////////////冒泡排序///////////////////////////////////
     61                for(i=0;i<5;i++)     //5个电感
   \                     ??Read_ADC_1: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_2: (+1)
   \   00000078   0xB224             SXTH     R4,R4
   \   0000007A   0x2C05             CMP      R4,#+5
   \   0000007C   0xDA50             BGE      ??Read_ADC_3
     62                {
     63                   for(j=0;j<4;j++)  //五个数据排序
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x0006             MOVS     R6,R0
   \                     ??Read_ADC_4: (+1)
   \   00000082   0xB236             SXTH     R6,R6
   \   00000084   0x2E04             CMP      R6,#+4
   \   00000086   0xDA49             BGE      ??Read_ADC_5
     64                   {
     65                      for(k=0;k<4-j;k++)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x0005             MOVS     R5,R0
   \                     ??Read_ADC_6: (+1)
   \   0000008C   0xB22D             SXTH     R5,R5
   \   0000008E   0x2004             MOVS     R0,#+4
   \   00000090   0xB236             SXTH     R6,R6
   \   00000092   0x1B80             SUBS     R0,R0,R6
   \   00000094   0x4285             CMP      R5,R0
   \   00000096   0xDA3F             BGE      ??Read_ADC_7
     66                      {
     67                         if(ad_valu[i][k] > ad_valu[i][k+1])  //前面的比后面的大  则进行交换
   \   00000098   0x....             LDR      R0,??DataTable1
   \   0000009A   0xB224             SXTH     R4,R4
   \   0000009C   0x210A             MOVS     R1,#+10
   \   0000009E   0x4361             MULS     R1,R4,R1
   \   000000A0   0x1840             ADDS     R0,R0,R1
   \   000000A2   0xB22D             SXTH     R5,R5
   \   000000A4   0x2102             MOVS     R1,#+2
   \   000000A6   0x4369             MULS     R1,R5,R1
   \   000000A8   0x1840             ADDS     R0,R0,R1
   \   000000AA   0x2102             MOVS     R1,#+2
   \   000000AC   0x5E40             LDRSH    R0,[R0, R1]
   \   000000AE   0x....             LDR      R1,??DataTable1
   \   000000B0   0xB224             SXTH     R4,R4
   \   000000B2   0x220A             MOVS     R2,#+10
   \   000000B4   0x4362             MULS     R2,R4,R2
   \   000000B6   0x1889             ADDS     R1,R1,R2
   \   000000B8   0xB22D             SXTH     R5,R5
   \   000000BA   0x2202             MOVS     R2,#+2
   \   000000BC   0x436A             MULS     R2,R5,R2
   \   000000BE   0x5E89             LDRSH    R1,[R1, R2]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xDA27             BGE      ??Read_ADC_8
     68                         {
     69                            temp = ad_valu[i][k+1];
   \   000000C4   0x....             LDR      R0,??DataTable1
   \   000000C6   0xB224             SXTH     R4,R4
   \   000000C8   0x210A             MOVS     R1,#+10
   \   000000CA   0x4361             MULS     R1,R4,R1
   \   000000CC   0x1840             ADDS     R0,R0,R1
   \   000000CE   0xB22D             SXTH     R5,R5
   \   000000D0   0x2102             MOVS     R1,#+2
   \   000000D2   0x4369             MULS     R1,R5,R1
   \   000000D4   0x1840             ADDS     R0,R0,R1
   \   000000D6   0x2102             MOVS     R1,#+2
   \   000000D8   0x5E40             LDRSH    R0,[R0, R1]
   \   000000DA   0x0007             MOVS     R7,R0
     70                            ad_valu[i][k+1] = ad_valu[i][k];
   \   000000DC   0x....             LDR      R0,??DataTable1
   \   000000DE   0xB224             SXTH     R4,R4
   \   000000E0   0x210A             MOVS     R1,#+10
   \   000000E2   0x4361             MULS     R1,R4,R1
   \   000000E4   0x1840             ADDS     R0,R0,R1
   \   000000E6   0xB22D             SXTH     R5,R5
   \   000000E8   0x2102             MOVS     R1,#+2
   \   000000EA   0x4369             MULS     R1,R5,R1
   \   000000EC   0x1840             ADDS     R0,R0,R1
   \   000000EE   0x....             LDR      R1,??DataTable1
   \   000000F0   0xB224             SXTH     R4,R4
   \   000000F2   0x220A             MOVS     R2,#+10
   \   000000F4   0x4362             MULS     R2,R4,R2
   \   000000F6   0x1889             ADDS     R1,R1,R2
   \   000000F8   0xB22D             SXTH     R5,R5
   \   000000FA   0x2202             MOVS     R2,#+2
   \   000000FC   0x436A             MULS     R2,R5,R2
   \   000000FE   0x5A89             LDRH     R1,[R1, R2]
   \   00000100   0x8041             STRH     R1,[R0, #+2]
     71                            ad_valu[i][k] = temp;
   \   00000102   0x....             LDR      R0,??DataTable1
   \   00000104   0xB224             SXTH     R4,R4
   \   00000106   0x210A             MOVS     R1,#+10
   \   00000108   0x4361             MULS     R1,R4,R1
   \   0000010A   0x1840             ADDS     R0,R0,R1
   \   0000010C   0xB22D             SXTH     R5,R5
   \   0000010E   0x2102             MOVS     R1,#+2
   \   00000110   0x4369             MULS     R1,R5,R1
   \   00000112   0x5247             STRH     R7,[R0, R1]
     72                         }
     73                      }
   \                     ??Read_ADC_8: (+1)
   \   00000114   0x1C6D             ADDS     R5,R5,#+1
   \   00000116   0xE7B9             B        ??Read_ADC_6
     74                   }
   \                     ??Read_ADC_7: (+1)
   \   00000118   0x1C76             ADDS     R6,R6,#+1
   \   0000011A   0xE7B2             B        ??Read_ADC_4
     75                }
   \                     ??Read_ADC_5: (+1)
   \   0000011C   0x1C64             ADDS     R4,R4,#+1
   \   0000011E   0xE7AB             B        ??Read_ADC_2
     76                for(i=0;i<5;i++)    //求中间三项的和
   \                     ??Read_ADC_3: (+1)
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_9: (+1)
   \   00000124   0xB224             SXTH     R4,R4
   \   00000126   0x2C05             CMP      R4,#+5
   \   00000128   0xDA27             BGE      ??Read_ADC_10
     77                {
     78                   ad_sum[i] = ad_valu[i][1] + ad_valu[i][2] + ad_valu[i][3];
   \   0000012A   0x....             LDR      R0,??DataTable1
   \   0000012C   0xB224             SXTH     R4,R4
   \   0000012E   0x210A             MOVS     R1,#+10
   \   00000130   0x4361             MULS     R1,R4,R1
   \   00000132   0x1840             ADDS     R0,R0,R1
   \   00000134   0x8840             LDRH     R0,[R0, #+2]
   \   00000136   0x....             LDR      R1,??DataTable1
   \   00000138   0xB224             SXTH     R4,R4
   \   0000013A   0x220A             MOVS     R2,#+10
   \   0000013C   0x4362             MULS     R2,R4,R2
   \   0000013E   0x1889             ADDS     R1,R1,R2
   \   00000140   0x8889             LDRH     R1,[R1, #+4]
   \   00000142   0x1840             ADDS     R0,R0,R1
   \   00000144   0x....             LDR      R1,??DataTable1
   \   00000146   0xB224             SXTH     R4,R4
   \   00000148   0x220A             MOVS     R2,#+10
   \   0000014A   0x4362             MULS     R2,R4,R2
   \   0000014C   0x1889             ADDS     R1,R1,R2
   \   0000014E   0x88C9             LDRH     R1,[R1, #+6]
   \   00000150   0x1840             ADDS     R0,R0,R1
   \   00000152   0x4669             MOV      R1,SP
   \   00000154   0xB224             SXTH     R4,R4
   \   00000156   0x2202             MOVS     R2,#+2
   \   00000158   0x4362             MULS     R2,R4,R2
   \   0000015A   0x5288             STRH     R0,[R1, R2]
     79                   ad_valu1[i] = ad_sum[i] / 3;
   \   0000015C   0x4668             MOV      R0,SP
   \   0000015E   0xB224             SXTH     R4,R4
   \   00000160   0x2102             MOVS     R1,#+2
   \   00000162   0x4361             MULS     R1,R4,R1
   \   00000164   0x5E40             LDRSH    R0,[R0, R1]
   \   00000166   0x2103             MOVS     R1,#+3
   \   00000168   0x.... 0x....      BL       __aeabi_idiv
   \   0000016C   0xA903             ADD      R1,SP,#+12
   \   0000016E   0xB224             SXTH     R4,R4
   \   00000170   0x2202             MOVS     R2,#+2
   \   00000172   0x4362             MULS     R2,R4,R2
   \   00000174   0x5288             STRH     R0,[R1, R2]
     80                }
   \   00000176   0x1C64             ADDS     R4,R4,#+1
   \   00000178   0xE7D4             B        ??Read_ADC_9
     81             ////////////////////////滑动平均滤波/////////////////////////////
     82                for(i = 0;i < NM-1;i ++)  //取中间3位的值到前三位
   \                     ??Read_ADC_10: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_11: (+1)
   \   0000017E   0xB224             SXTH     R4,R4
   \   00000180   0x2C02             CMP      R4,#+2
   \   00000182   0xDA41             BGE      ??Read_ADC_12
     83                {
     84                    AD_V[0][i] = ad_valu[0][i + 1];
   \   00000184   0x....             LDR      R0,??DataTable1
   \   00000186   0xB224             SXTH     R4,R4
   \   00000188   0x2102             MOVS     R1,#+2
   \   0000018A   0x4361             MULS     R1,R4,R1
   \   0000018C   0x1840             ADDS     R0,R0,R1
   \   0000018E   0x2102             MOVS     R1,#+2
   \   00000190   0x5E40             LDRSH    R0,[R0, R1]
   \   00000192   0x....             LDR      R1,??DataTable1_1
   \   00000194   0xB224             SXTH     R4,R4
   \   00000196   0x2204             MOVS     R2,#+4
   \   00000198   0x4362             MULS     R2,R4,R2
   \   0000019A   0x5088             STR      R0,[R1, R2]
     85                    AD_V[1][i] = ad_valu[1][i + 1];
   \   0000019C   0x....             LDR      R0,??DataTable1
   \   0000019E   0xB224             SXTH     R4,R4
   \   000001A0   0x2102             MOVS     R1,#+2
   \   000001A2   0x4361             MULS     R1,R4,R1
   \   000001A4   0x1840             ADDS     R0,R0,R1
   \   000001A6   0x210C             MOVS     R1,#+12
   \   000001A8   0x5E40             LDRSH    R0,[R0, R1]
   \   000001AA   0x....             LDR      R1,??DataTable1_1
   \   000001AC   0xB224             SXTH     R4,R4
   \   000001AE   0x2204             MOVS     R2,#+4
   \   000001B0   0x4362             MULS     R2,R4,R2
   \   000001B2   0x1889             ADDS     R1,R1,R2
   \   000001B4   0x60C8             STR      R0,[R1, #+12]
     86                    AD_V[2][i] = ad_valu[2][i + 1];
   \   000001B6   0x....             LDR      R0,??DataTable1
   \   000001B8   0xB224             SXTH     R4,R4
   \   000001BA   0x2102             MOVS     R1,#+2
   \   000001BC   0x4361             MULS     R1,R4,R1
   \   000001BE   0x1840             ADDS     R0,R0,R1
   \   000001C0   0x2116             MOVS     R1,#+22
   \   000001C2   0x5E40             LDRSH    R0,[R0, R1]
   \   000001C4   0x....             LDR      R1,??DataTable1_1
   \   000001C6   0xB224             SXTH     R4,R4
   \   000001C8   0x2204             MOVS     R2,#+4
   \   000001CA   0x4362             MULS     R2,R4,R2
   \   000001CC   0x1889             ADDS     R1,R1,R2
   \   000001CE   0x6188             STR      R0,[R1, #+24]
     87                    AD_V[3][i] = ad_valu[3][i + 1];
   \   000001D0   0x....             LDR      R0,??DataTable1
   \   000001D2   0xB224             SXTH     R4,R4
   \   000001D4   0x2102             MOVS     R1,#+2
   \   000001D6   0x4361             MULS     R1,R4,R1
   \   000001D8   0x1840             ADDS     R0,R0,R1
   \   000001DA   0x2120             MOVS     R1,#+32
   \   000001DC   0x5E40             LDRSH    R0,[R0, R1]
   \   000001DE   0x....             LDR      R1,??DataTable1_1
   \   000001E0   0xB224             SXTH     R4,R4
   \   000001E2   0x2204             MOVS     R2,#+4
   \   000001E4   0x4362             MULS     R2,R4,R2
   \   000001E6   0x1889             ADDS     R1,R1,R2
   \   000001E8   0x6248             STR      R0,[R1, #+36]
     88                    AD_V[4][i] = ad_valu[4][i + 1];
   \   000001EA   0x....             LDR      R0,??DataTable1
   \   000001EC   0xB224             SXTH     R4,R4
   \   000001EE   0x2102             MOVS     R1,#+2
   \   000001F0   0x4361             MULS     R1,R4,R1
   \   000001F2   0x1840             ADDS     R0,R0,R1
   \   000001F4   0x212A             MOVS     R1,#+42
   \   000001F6   0x5E40             LDRSH    R0,[R0, R1]
   \   000001F8   0x....             LDR      R1,??DataTable1_1
   \   000001FA   0xB224             SXTH     R4,R4
   \   000001FC   0x2204             MOVS     R2,#+4
   \   000001FE   0x4362             MULS     R2,R4,R2
   \   00000200   0x1889             ADDS     R1,R1,R2
   \   00000202   0x6308             STR      R0,[R1, #+48]
     89                }
   \   00000204   0x1C64             ADDS     R4,R4,#+1
   \   00000206   0xE7BA             B        ??Read_ADC_11
     90                for(i=0;i<5;i++)   //第三位存储平均值
   \                     ??Read_ADC_12: (+1)
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_13: (+1)
   \   0000020C   0xB224             SXTH     R4,R4
   \   0000020E   0x2C05             CMP      R4,#+5
   \   00000210   0xDA0C             BGE      ??Read_ADC_14
     91                {
     92                    AD_V[i][NM-1] =  ad_valu1[i];
   \   00000212   0xA803             ADD      R0,SP,#+12
   \   00000214   0xB224             SXTH     R4,R4
   \   00000216   0x2102             MOVS     R1,#+2
   \   00000218   0x4361             MULS     R1,R4,R1
   \   0000021A   0x5E40             LDRSH    R0,[R0, R1]
   \   0000021C   0x....             LDR      R1,??DataTable1_1
   \   0000021E   0xB224             SXTH     R4,R4
   \   00000220   0x220C             MOVS     R2,#+12
   \   00000222   0x4362             MULS     R2,R4,R2
   \   00000224   0x1889             ADDS     R1,R1,R2
   \   00000226   0x6088             STR      R0,[R1, #+8]
     93                }
   \   00000228   0x1C64             ADDS     R4,R4,#+1
   \   0000022A   0xE7EF             B        ??Read_ADC_13
     94                   for(i = 0;i < NM;i ++)   //得到原中间三位的值
   \                     ??Read_ADC_14: (+1)
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_15: (+1)
   \   00000230   0xB224             SXTH     R4,R4
   \   00000232   0x2C03             CMP      R4,#+3
   \   00000234   0xDA37             BGE      ??Read_ADC_16
     95                {
     96                    AD_sum[0] += AD_V[0][i];
   \   00000236   0x....             LDR      R0,??DataTable1_2
   \   00000238   0x6800             LDR      R0,[R0, #+0]
   \   0000023A   0x....             LDR      R1,??DataTable1_1
   \   0000023C   0xB224             SXTH     R4,R4
   \   0000023E   0x2204             MOVS     R2,#+4
   \   00000240   0x4362             MULS     R2,R4,R2
   \   00000242   0x5889             LDR      R1,[R1, R2]
   \   00000244   0x1840             ADDS     R0,R0,R1
   \   00000246   0x....             LDR      R1,??DataTable1_2
   \   00000248   0x6008             STR      R0,[R1, #+0]
     97                    AD_sum[1] += AD_V[1][i];
   \   0000024A   0x....             LDR      R0,??DataTable1_2
   \   0000024C   0x6840             LDR      R0,[R0, #+4]
   \   0000024E   0x....             LDR      R1,??DataTable1_1
   \   00000250   0xB224             SXTH     R4,R4
   \   00000252   0x2204             MOVS     R2,#+4
   \   00000254   0x4362             MULS     R2,R4,R2
   \   00000256   0x1889             ADDS     R1,R1,R2
   \   00000258   0x68C9             LDR      R1,[R1, #+12]
   \   0000025A   0x1840             ADDS     R0,R0,R1
   \   0000025C   0x....             LDR      R1,??DataTable1_2
   \   0000025E   0x6048             STR      R0,[R1, #+4]
     98                    AD_sum[2] += AD_V[2][i];
   \   00000260   0x....             LDR      R0,??DataTable1_2
   \   00000262   0x6880             LDR      R0,[R0, #+8]
   \   00000264   0x....             LDR      R1,??DataTable1_1
   \   00000266   0xB224             SXTH     R4,R4
   \   00000268   0x2204             MOVS     R2,#+4
   \   0000026A   0x4362             MULS     R2,R4,R2
   \   0000026C   0x1889             ADDS     R1,R1,R2
   \   0000026E   0x6989             LDR      R1,[R1, #+24]
   \   00000270   0x1840             ADDS     R0,R0,R1
   \   00000272   0x....             LDR      R1,??DataTable1_2
   \   00000274   0x6088             STR      R0,[R1, #+8]
     99                    AD_sum[3] += AD_V[3][i];
   \   00000276   0x....             LDR      R0,??DataTable1_2
   \   00000278   0x68C0             LDR      R0,[R0, #+12]
   \   0000027A   0x....             LDR      R1,??DataTable1_1
   \   0000027C   0xB224             SXTH     R4,R4
   \   0000027E   0x2204             MOVS     R2,#+4
   \   00000280   0x4362             MULS     R2,R4,R2
   \   00000282   0x1889             ADDS     R1,R1,R2
   \   00000284   0x6A49             LDR      R1,[R1, #+36]
   \   00000286   0x1840             ADDS     R0,R0,R1
   \   00000288   0x....             LDR      R1,??DataTable1_2
   \   0000028A   0x60C8             STR      R0,[R1, #+12]
    100                    AD_sum[4] += AD_V[4][i];
   \   0000028C   0x....             LDR      R0,??DataTable1_2
   \   0000028E   0x6900             LDR      R0,[R0, #+16]
   \   00000290   0x....             LDR      R1,??DataTable1_1
   \   00000292   0xB224             SXTH     R4,R4
   \   00000294   0x2204             MOVS     R2,#+4
   \   00000296   0x4362             MULS     R2,R4,R2
   \   00000298   0x1889             ADDS     R1,R1,R2
   \   0000029A   0x6B09             LDR      R1,[R1, #+48]
   \   0000029C   0x1840             ADDS     R0,R0,R1
   \   0000029E   0x....             LDR      R1,??DataTable1_2
   \   000002A0   0x6108             STR      R0,[R1, #+16]
    101                }
   \   000002A2   0x1C64             ADDS     R4,R4,#+1
   \   000002A4   0xE7C4             B        ??Read_ADC_15
    102                for(i=0;i<5;i++)  //求平均
   \                     ??Read_ADC_16: (+1)
   \   000002A6   0x2000             MOVS     R0,#+0
   \   000002A8   0x0004             MOVS     R4,R0
   \                     ??Read_ADC_17: (+1)
   \   000002AA   0xB224             SXTH     R4,R4
   \   000002AC   0x2C05             CMP      R4,#+5
   \   000002AE   0xDA14             BGE      ??Read_ADC_18
    103                {
    104                    AD_valu[i] = AD_sum[i] / NM;
   \   000002B0   0x....             LDR      R0,??DataTable1_2
   \   000002B2   0xB224             SXTH     R4,R4
   \   000002B4   0x2104             MOVS     R1,#+4
   \   000002B6   0x4361             MULS     R1,R4,R1
   \   000002B8   0x5840             LDR      R0,[R0, R1]
   \   000002BA   0x2103             MOVS     R1,#+3
   \   000002BC   0x.... 0x....      BL       __aeabi_idiv
   \   000002C0   0x....             LDR      R1,??DataTable1_3
   \   000002C2   0xB224             SXTH     R4,R4
   \   000002C4   0x2204             MOVS     R2,#+4
   \   000002C6   0x4362             MULS     R2,R4,R2
   \   000002C8   0x5088             STR      R0,[R1, R2]
    105                    AD_sum[i] = 0;
   \   000002CA   0x2000             MOVS     R0,#+0
   \   000002CC   0x....             LDR      R1,??DataTable1_2
   \   000002CE   0xB224             SXTH     R4,R4
   \   000002D0   0x2204             MOVS     R2,#+4
   \   000002D2   0x4362             MULS     R2,R4,R2
   \   000002D4   0x5088             STR      R0,[R1, R2]
    106                }
   \   000002D6   0x1C64             ADDS     R4,R4,#+1
   \   000002D8   0xE7E7             B        ??Read_ADC_17
    107          }
   \                     ??Read_ADC_18: (+1)
   \   000002DA   0xB007             ADD      SP,SP,#+28
   \   000002DC   0xBDF0             POP      {R4-R7,PC}       ;; return
    108          
    109          
    110          
    111          
    112          
    113          
    114          
    115          
    116          
    117          
    118          ///*************************************************************************
    119          // *  函数名称   Date_analyse
    120          // *  功能说明： 数据分析
    121          // *  参数说明：
    122          // *  函数返回： 无
    123          // *  修改时间：
    124          // *  备    注：
    125          //*************************************************************************/
    126          //void Date_analyse()
    127          //{
    128          ////     char Chazhi_flag = 0;
    129          ////     char Chazhi_value[11];
    130          ////     int16  a,b;
    131          //     int16  i,max_front=0,max_back;
    132          //     static int16 max_old = 1,max_crosstalk = 1;
    133          //     static int16 position_last = 2;
    134          //     float  sensor_1;
    135          //
    136          //     Read_ADC();
    137          //
    138          //    Inductor_Check();//电感最大最小值校验 
    139          //     /*********************归一化处理********************/
    140          //     for(i=0;i<5;i++)
    141          //     {
    142          //        sensor_to_one[i] = (float)(AD_valu[i] - min_v[i])/(float)(max_v[i]- min_v[i]);
    143          //      if(sensor_to_one[i]<=0.0)  sensor_to_one[i]=0.001;
    144          ////        if(sensor_to_one[0]<=0.0)  sensor_to_one[0]=0.001;
    145          ////        if(sensor_to_one[0]>1.0)  sensor_to_one[0]=1.0;
    146          ////        
    147          ////        if(sensor_to_one[2]<=0.0)  sensor_to_one[2]=0.001;
    148          ////        if(sensor_to_one[2]>1.0)  sensor_to_one[2]=1.0;
    149          //
    150          //        AD_inductor[i] = 100 * sensor_to_one[i];     //AD[i]为归一化后的值  范围为0-100
    151          //     }
    152          //       /*******1号电感特殊归一化，用于坡道检测********/
    153          //      sensor_1 = (float)(AD_valu[1] - min_v[1])/(float)(ad_valu[1][0] - min_v[1]);
    154          //      if(sensor_1 <= 0.0)  sensor_1 = 0.001;
    155          //      Slope_AD_1 = 100 * sensor_1;
    156          //   ////////////////////////////////////////////////////////////////////
    157          //
    158          //       for(i=0;i<3;i++)                 //找出最强的传感器
    159          //       {
    160          //         if(AD_inductor[max_front]<AD_inductor[i])
    161          //           max_front=i;
    162          //       }
    163          //       max_value=AD_inductor[max_front];  //最大电感值
    164          //
    165          //    //   max_back = (AD_inductor[3]>AD_inductor[4])? 3:4;  //找后排最强电感
    166          // //zs屏蔽      
    167          //       //丢线时最大值取旧值
    168          //       if(max_value < 5)           
    169          //       {
    170          //         max_front=max_old;
    171          //         max_value=AD_inductor[max_front];
    172          //       }
    173          //       else
    174          //         max_old=max_front;
    175          ////       //防串道
    176          //       if(abs_inductor(max_front - max_crosstalk) < 2)  
    177          //       {
    178          //            max_crosstalk = max_front;
    179          //       }
    180          //       else
    181          //            max_front = max_crosstalk;
    182          // //张盛屏蔽      
    183          //      // AD_MAX_NUM = max_front;        //传送速度控制
    184          //       
    185          //        /****************位置解算，解算过程的值用归一化放大后的值************************/
    186          ////zs1    
    187          //       
    188          ////       if((max_front==0&&AD_inductor[1] > 5)||(max_front==1 && (AD_inductor[0] > AD_inductor[2])  ))
    189          ////       {
    190          ////           position=1;         
    191          ////       }
    192          ////       if((max_front==0&&AD_inductor[1] > 5)||(max_front==1 && (AD_inductor[0] < AD_inductor[2])  ))
    193          ////       {
    194          ////           position=2;         
    195          ////       }
    196          ////         
    197          ////         
    198          ////ZS2       
    199          //        if(max_front==0 && (AD_inductor[1] <= Position_transit[0] ))  //已经偏离0号传感器
    200          //       {//右电感最大且此时的中电感值<=过渡点0时中电感的值
    201          //             position=0;//右电感在电磁线左方，整个小车都在电磁线左方
    202          // //          AD_0_max = AD_inductor[0];//zs加
    203          //       }
    204          //       else if((max_front==0 && (AD_inductor[1] > Position_transit[0] )) || (max_front==1 && (AD_inductor[0] >AD_inductor[2]) ))  //左侧位置  0-1号传感器之间
    205          //       {//右电感最大且此时中电感的值>过渡点0时中电感的值||中电感最大且右电感的值>左电感的值
    206          //           //      中电感在电磁线左边                            中电感在电磁线左边
    207          //             position=1;//中电感在电磁线左边,小车偏左(半个小车以上部分在电磁线左边但不是全部)
    208          //             AD_0_max = AD_inductor[0]; //记录下此时的0号传感器的归一放大后的值
    209          //       }
    210          //       else if((max_front==1 && (AD_inductor[2] >AD_inductor[0]) ) || (max_front==2 && (AD_inductor[1] > Position_transit[1] )))  //右侧位置  1-2号传感器之间
    211          //       {//中电感最大且左电感的值大于右电感的值||左电感最大且此时中电感的值>过渡点1时中电感的值
    212          //        //    中电感在电磁线右边                         中电感在电磁线右边          
    213          //             position=2;//中电感在电磁线右边,小车偏右(半个小车以上部分在电磁线右边但不是全部)
    214          //             AD_2_max = AD_inductor[2]; //记录下此时的3号传感器归一放大后的值
    215          //       }
    216          //       else if(max_front==2 && (AD_inductor[1] <= Position_transit[1] ))  //已经偏离3号传感器
    217          //       {//左电感最大且此时的中电感值<=过渡点1时中电感的值
    218          //             position = 3;//左电感在电磁线右方，整个小车都在电磁线右方
    219          //        // AD_2_max = AD_inductor[2];//zs加
    220          //
    221          //       }   
    222          //         
    223          //         
    224          ////Position_transit[0]:右电感位于电磁线正上方时中电感归一化放大后的值
    225          ////Position_transit[1]:左电感位于电磁线正上方时中电感归一化放大后的值中电感的值
    226          ////       if(max_front==0 && (AD_inductor[1] <= Position_transit[0] ))  //已经偏离0号传感器
    227          ////       {//右电感最大且此时的中电感值<=过渡点0时中电感的值
    228          ////             position=0;//右电感在电磁线左方，整个小车都在电磁线左方
    229          //// //          AD_0_max = AD_inductor[0];//zs加
    230          ////       }
    231          ////       else if((max_front==0 && (AD_inductor[1] > Position_transit[0] + 1)) || (max_front==1 && (AD_inductor[0] - AD_inductor[2]) > 1))  //左侧位置  0-1号传感器之间
    232          ////       {//右电感最大且此时中电感的值>过渡点0时中电感的值||中电感最大且右电感的值>左电感的值
    233          ////           //      中电感在电磁线左边                            中电感在电磁线左边
    234          ////             position=1;//中电感在电磁线左边,小车偏左(半个小车以上部分在电磁线左边但不是全部)
    235          ////             AD_0_max = AD_inductor[0]; //记录下此时的0号传感器的归一放大后的值
    236          ////       }
    237          ////       else if((max_front==1 && (AD_inductor[2] - AD_inductor[0]) > 1) || (max_front==2 && (AD_inductor[1] > Position_transit[1] + 1)))  //右侧位置  1-2号传感器之间
    238          ////       {//中电感最大且左电感的值大于右电感的值||左电感最大且此时中电感的值>过渡点1时中电感的值
    239          ////        //    中电感在电磁线右边                         中电感在电磁线右边          
    240          ////             position=2;//中电感在电磁线右边,小车偏右(半个小车以上部分在电磁线右边但不是全部)
    241          ////             AD_2_max = AD_inductor[2]; //记录下此时的3号传感器归一放大后的值
    242          ////       }
    243          ////       else if(max_front==2 && (AD_inductor[1] <= Position_transit[1] - 1))  //已经偏离3号传感器
    244          ////       {//左电感最大且此时的中电感值<=过渡点1时中电感的值
    245          ////             position = 3;//左电感在电磁线右方，整个小车都在电磁线右方
    246          ////        // AD_2_max = AD_inductor[2];//zs加
    247          ////
    248          ////       }
    249          //       /*
    250          //       //~~~~~~~~~~~~~~~~~~~~~~~ 后排位置解算~~~~~~~~~~~~~~~~~~~//
    251          //       if(max_back == 3 && AD_inductor[4] <= Position_transit[2] - 1)
    252          //       {
    253          //            if(AD_inductor[4] <= Position_transit[2] - 22)
    254          //               position_back = 0;
    255          //            if(AD_inductor[4] >= Position_transit[2] - 20)
    256          //               position_back = 1;
    257          //       }
    258          //       else  if(max_back == 3 && AD_inductor[4] > Position_transit[2] + 1 || max_back == 4 && AD_inductor[3] > Position_transit[3] + 1)
    259          //       {
    260          //            position_back = 2;
    261          //       }
    262          //       else if(max_back == 4 && AD_inductor[3] <= Position_transit[3] - 1)
    263          //       {
    264          //            if(AD_inductor[3] >= Position_transit[3] - 20)
    265          //               position_back = 3;
    266          //            if(AD_inductor[3] <= Position_transit[3] - 22)
    267          //               position_back = 4;
    268          //       }
    269          //       */
    270          //      /*位置防跳变过大，比如前1ms小车都在电磁线左边，后1ms小车偏右*/  
    271          // //zs屏蔽      
    272          //       if(abs_inductor(position - position_last) > 1)  //位置跳变过大时进入 
    273          //       {
    274          //            position = position_last;//此刻小车位置转变为上一次小车位置
    275          //       }
    276          //       else
    277          //       {
    278          //       position_last = position;//正常记录，接下来的上次小车位置=此刻小车位置
    279          //       }   
    280          ////zs屏蔽
    281          ////////弯道内和导线夹角过大导致后面转向不足，此时过渡点强制增大//////////////
    282          ///*用于小车直道太偏或过弯道时小车转弯幅度小不给力，小车不能好好的给过弯道，此时强制*/
    283          ////当在直道整个小车太过偏左都在电磁线左边时且此时最强的右电感值<75,说明小车太偏了，进入if
    284          ////当遇到弯道小车转弯幅度不够，可能会冲出赛道，进入if 
    285          //       
    286          //      //////弯道内和导线夹角过大导致后面转向不足，此时过渡点强制增大//////////////
    287          ////张盛屏蔽
    288          ////       if(position == 0 && AD_0_max < 75)
    289          ////       {
    290          ////           AD_0_max = 75 + abs_f(75 - AD_0_max);
    291          ////       }
    292          ////       else if(position == 3 && AD_2_max < 75)
    293          ////       {
    294          ////           AD_2_max = 75 + abs_f(75 - AD_2_max);
    295          ////       }
    296          ////张盛屏蔽
    297          //  Chazhi_Last=Chazhi;
    298          //       /*************计算偏移量*************/
    299          ////zs
    300          ////    Chazhi = (int16)(AD_inductor[2] - AD_inductor[0]);
    301          ////   if(position ==1)  
    302          ////   {
    303          ////      if(AD_inductor[0]>50&&AD_inductor[0]>AD_inductor[1]&&AD_inductor[1]>AD_inductor[2]&&AD_inductor[2]<5)
    304          ////        Chazhi=-70;
    305          ////   }
    306          ////   
    307          ////    if(position ==2)  
    308          ////   {
    309          ////      if(AD_inductor[2]>50&&AD_inductor[2]>AD_inductor[1 ]&&AD_inductor[1]>AD_inductor[0]&&AD_inductor[0]<5)
    310          ////        Chazhi=70;
    311          ////   }
    312          //  
    313          //       if(position == 0)   //左侧丢线
    314          //       {
    315          //       
    316          //            Chazhi =-60;
    317          //       }
    318          //       else if(position == 1 || position == 2) //处于中间位置        
    319          //       {
    320          //                  
    321          //             Chazhi = (int16)(AD_inductor[2] - AD_inductor[0]); 
    322          //             
    323          //             
    324          //       }
    325          //       else if(position == 3)  //右侧丢线
    326          //       {
    327          //            Chazhi = 60;
    328          //       }
    329          //     
    330          //
    331          //      
    332          //       /*
    333          //       if(Strig  ht_Flag)
    334          //       {
    335          //           Chazhi = (int16)(((AD_inductor[2]-AD_inductor[0])-(AD_inductor[4]-AD_inductor[3])/10)*1.3);  //长直道用斜率控制舵机
    336          //       }
    337          //       if(UPhill_flag)  //上坡时 强制用两侧电感偏移量
    338          //       {
    339          //           Chazhi = (int16)((AD_inductor[2] - AD_inductor[0]));
    340          //       }
    341          //       */
    342          //       
    343          //         
    344          //       
    345          //
    346          //}
    347          //
    348          //
    349          
    350          
    351          
    352          
    353          
    354          
    355          //延时

   \                                 In section .text, align 2, keep-with-next
    356          void delayms(unsigned int time)
    357          {
   \                     delayms: (+1)
   \   00000000   0xB500             PUSH     {LR}
    358             unsigned int i=0;
   \   00000002   0x2100             MOVS     R1,#+0
    359             while(time--)
   \                     ??delayms_0: (+1)
   \   00000004   0x0002             MOVS     R2,R0
   \   00000006   0x1E50             SUBS     R0,R2,#+1
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD006             BEQ      ??delayms_1
    360             {
    361                i=12000;  //自己定义
   \   0000000C   0x....             LDR      R2,??DataTable1_4  ;; 0x2ee0
   \   0000000E   0x0011             MOVS     R1,R2
    362                while(i--);
   \                     ??delayms_2: (+1)
   \   00000010   0x000A             MOVS     R2,R1
   \   00000012   0x1E51             SUBS     R1,R2,#+1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD1FB             BNE      ??delayms_2
   \   00000018   0xE7F4             B        ??delayms_0
    363             }
    364          }
   \                     ??delayms_1: (+1)
   \   0000001A   0xBD00             POP      {PC}             ;; return
    365          
    366          ///取绝对值

   \                                 In section .text, align 2, keep-with-next
    367          uint16 abs_inductor(int value)
    368          {
   \                     abs_inductor: (+1)
   \   00000000   0xB500             PUSH     {LR}
    369              if(value<0)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD501             BPL      ??abs_inductor_0
    370                value=-value;
   \   00000006   0x4241             RSBS     R1,R0,#+0
   \   00000008   0x0008             MOVS     R0,R1
    371              return value;
   \                     ??abs_inductor_0: (+1)
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0xBD00             POP      {PC}             ;; return
    372          }
    373          

   \                                 In section .text, align 2, keep-with-next
    374          float abs_f(float value)
    375          {
   \                     abs_f: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    376              if(value<0)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000008   0xD202             BCS      ??abs_f_0
    377                value=-value;
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x0609             LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000000E   0x4048             EORS     R0,R0,R1
    378              return value;
   \                     ??abs_f_0: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    379          }
    380          
    381          
    382          
    383          
    384          /*************************************************************************
    385           *  函数名称   SC_black_Init
    386           *  功能说明： AD初始化  将电感的最大值 以及 过渡点写入FLASH
    387           *  参数说明：
    388           *  函数返回： 无
    389           *  修改时间：
    390           *  备    注：
    391          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    392          void SC_black_Init(void)
    393          {
    394          //    uint16  i,j;
    395          //    float  *Ptr_flash=NULL;
    396          //    int16   Position_transit_short[4];
    397          //    float  sensor_1,sensor_2,sensor_3,sensor_4;
    398          //    flag_1 = 1;
    399          //
    400          //    if(inductor_flag)
    401          //    {
    402          //     inductor_flag = 0;
    403          ////     UART_Send_String("Collecting");
    404          ////     UART_Send_String("samples...");
    405          //
    406          //        max_v[0] = max_v[1] = max_v[2] = max_v[3] = max_v[4] = 0;
    407          //        for(i=0;i<100;i++)
    408          //        {
    409          //
    410          //            AD_valu[0] = ADC_Once(ADC_1,adc10bit);  //左  通道
    411          //            AD_valu[1] = ADC_Once(ADC_2,adc10bit);  //中  通道
    412          //            AD_valu[2] = ADC_Once(ADC_3,adc10bit);  //右  通道
    413          ////            AD_valu[3] = ADC_Once(ADC_4,adc10bit);  //中1 通道
    414          ////            AD_valu[4] = ADC_Once(ADC_5,adc10bit);  //中2 通道
    415          //            if(AD_valu[2]>300) AD_valu[2] = 250;
    416          //            
    417          //            for(j=0;j<3;j++)
    418          //            {
    419          //                if(AD_valu[j] > max_v[j])
    420          //                {
    421          //                    max_v[j] = AD_valu[j];
    422          //                    if(j==0)    Position_transit_short[0] =  AD_valu[1];  //记录过渡点 电感值
    423          //                    if(j==2)    Position_transit_short[1] =  AD_valu[1];
    424          ////                    if(j==3)    Position_transit_short[2] =  AD_valu[4];
    425          ////                    if(j==4)    Position_transit_short[3] =  AD_valu[3];
    426          //                }
    427          //            }
    428          //          
    429          //        }
    430          //        /***************              记录的过渡点归一化                     ******************/
    431          //        sensor_1 = (float)(Position_transit_short[0] - min_v[1])/(float)(max_v[1] - min_v[1]);
    432          //        if(sensor_1 <= 0.0)  sensor_1 = 0.001;
    433          //        if(sensor_1 >= 1.0)  sensor_1 = 1.0;
    434          //
    435          //        sensor_2 = (float)(Position_transit_short[1] - min_v[1])/(float)(max_v[1] - min_v[1]);
    436          //        if(sensor_2 <= 0.0)  sensor_2 = 0.001;
    437          //        if(sensor_2 >= 1.0)  sensor_2 = 1.0;
    438          //
    439          ////        sensor_3 = (float)(Position_transit_short[2] - min_v[4])/(float)(max_v[4] - min_v[4]);
    440          ////        if(sensor_3 <= 0.0)  sensor_3 = 0.001;/
    441          ////        if(sensor_3 >= 1.0)  sensor_3 = 1.0;
    442          ////
    443          ////        sensor_4 = (float)(Position_transit_short[3] - min_v[3])/(float)(max_v[3] - min_v[3]);
    444          ////        if(sensor_4 <= 0.0)  sensor_4 = 0.001;
    445          ////        if(sensor_4 >= 1.0)  sensor_4 = 1.0;
    446          //
    447          //        //扩大过渡点的值
    448          //        Position_transit[0] = (int16)(100 * sensor_1);
    449          //        Position_transit[1] = (int16)(100 * sensor_2);
    450          ////        Position_transit[2] = (int16)(100 * sensor_3);
    451          ////        Position_transit[3] = (int16)(100 * sensor_4);
    452          //
    453          //
    454          //        //将过渡值和最大值写到FASH里面
    455          //    /*
    456          //        result=LPLD_Flash_SectorErase((uint32)SECTOR_ADM);//擦除254扇区
    457          //        if(result == FLASH_OK)printf(0,0,"Eraser successful!");
    458          //
    459          //
    460          //        result=LPLD_Flash_ByteProgram((uint32)SECTOR_ADM, (uint32*)max_v, DATA_SIZE*4); //电感标定的最大值写入扇区
    461          //        if(result == FLASH_OK)printf(0,0,"Write max successful!");
    462          //
    463          //
    464          //        result=LPLD_Flash_ByteProgram((uint32)SECTOR_ADM+20, (uint32*)Position_transit, 4*4);
    465          //        if(result == FLASH_OK)printf(0,0,"Write Position_transit successful!");
    466          //        */
    467          //
    468          //
    469          //        /*
    470          //        for(i=0;i<4;i++)                     //过渡点归一化值写入扇区
    471          //        {
    472          //           LPLD_Flash_ByteProgram(SECTOR_ADM,20+i*4,Position_transit[i]);
    473          //        }
    474          //        */
    475          ////    }
    476          //    
    477          ////    else
    478          ////    {
    479          ////        for(i=0;i<3;i++)
    480          ////        {
    481          ////          /*
    482          ////          Ptr_flash = (float*)SECTOR_ADM;  没写ROM 报错  改
    483          ////          */
    484          ////           for(j=0;j<5;j++)   //读取五个电感的采样标定的最大值
    485          ////           {
    486          ////               max_v[j] = *(Ptr_flash+j);
    487          ////           }
    488          ////           for(j=0;j<4;j++)  //读取过渡点
    489          ////           {
    490          ////              Position_transit[j] = *(Ptr_flash+20+j);
    491          ////           }
    492          ////
    493          ////           UART_Send_String("Reading");
    494          ////           UART_Send_String("samples...");
    495          ////          // delayms(10);
    496          ////        }
    497          //    }
    498          
    499          
    500           }
   \                     SC_black_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     ad_valu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     AD_V

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     AD_sum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     AD_valu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x00002EE0         DC32     0x2ee0
    501          
    502          
    503          
    504          
    505          
    506          
    507          
    508          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   Read_ADC
        48   -> ADC_Once
        48 __aeabi_idiv
       0   SC_black_Init
       8   abs_f
         8 __aeabi_cfcmple
       4   abs_inductor
       4   delayms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
     734  Read_ADC
       2  SC_black_Init
      18  abs_f
      14  abs_inductor
      28  delayms

 
 816 bytes in section .text
 
 816 bytes of CODE memory

Errors: none
Warnings: none
