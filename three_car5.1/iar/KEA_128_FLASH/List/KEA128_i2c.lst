###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        01/May/2018  16:13:21
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  H:\智能车程序2018\电磁三轮――ZS\5.1\lib\C\KEA128_i2c.c
#    Command line =  
#        H:\智能车程序2018\电磁三轮――ZS\5.1\lib\C\KEA128_i2c.c -D IAR -D
#        TWR_K60N512 -D _DLIB_FILE_DESCRIPTOR -lCN
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\List\ -lB
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\List\ -o
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None
#        --dlib_config F:\IAR安装包\arm\INC\c\DLib_Config_Normal.h -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\device\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\user\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\system\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\lib\H\ -I
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\..\system\coreSupport\ -On
#    List file    =  
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\List\KEA128_i2c.lst
#    Object file  =  
#        H:\智能车程序2018\电磁三轮――ZS\5.1\iar\KEA_128_FLASH\Obj\KEA128_i2c.o
#
###############################################################################

H:\智能车程序2018\电磁三轮――ZS\5.1\lib\C\KEA128_i2c.c
      1          /*********************************************************************************************************************
      2           * COPYRIGHT NOTICE
      3           * Copyright (c) 2017,逐飞科技
      4           * All rights reserved.
      5           * 技术讨论QQ群：179029047
      6           *
      7           * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
      8           * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
      9           *
     10           * @file       		KEA128_i2c
     11           * @company	   		成都逐飞科技有限公司
     12           * @author     		逐飞科技(QQ3184284598)
     13           * @version    		v2.0
     14           * @Software 		IAR 7.7 or MDK 5.23
     15           * @Target core		S9KEA128AMLK
     16           * @Taobao   		https://seekfree.taobao.com/
     17           * @date       		2017-11-6
     18           ********************************************************************************************************************/
     19          
     20          
     21          #include "KEA128_i2c.h"
     22          

   \                                 In section .bss, align 1
     23          unsigned char MasterTransmission;
   \                     MasterTransmission:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     24          unsigned char SlaveID;
   \                     SlaveID:
   \   00000000                      DS8 1
     25          

   \                                 In section .data, align 4
     26          I2C_Type * I2CN[2] = I2C_BASES; //定义两个指针数组保存 I2CN 的地址
   \                     I2CN:
   \   00000000   0x40066000         DC32 40066000H, 40067000H
   \              0x40067000   
     27          
     28          
     29          //等待 I2C_S  不会出现卡死的情况

   \                                 In section .text, align 2, keep-with-next
     30          void i2c_Wait(I2Cn_e i2cn)
     31          {
   \                     i2c_Wait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     32              uint16 num;
     33              uint16 wait_num=500;//等待次数，超过设定的次数将关闭硬件IIC，使用模拟IIC发出stop信号，然后在启动硬件IIC。
   \   00000004   0x26FA             MOVS     R6,#+250
   \   00000006   0x0076             LSLS     R6,R6,#+1        ;; #+500
     34                                  //这里的500在通信速率为100K的时候可以正常使用，如果通信速率较低可以适当增加这个值。
     35                                  //经过测试可以在通信出错的时候，自动恢复。
     36              while(( I2CN[i2cn]->S & I2C_S_IICIF_MASK)==0)
   \                     ??i2c_Wait_0: (+1)
   \   00000008   0x....             LDR      R0,??DataTable2
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4361             MULS     R1,R4,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x78C0             LDRB     R0,[R0, #+3]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD43B             BMI      ??i2c_Wait_1
     37              {
     38                  num++;
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
     39                  if(num>wait_num)
   \   0000001A   0xB2B6             UXTH     R6,R6
   \   0000001C   0xB2AD             UXTH     R5,R5
   \   0000001E   0x42AE             CMP      R6,R5
   \   00000020   0xD2F2             BCS      ??i2c_Wait_0
     40                  {
     41                      I2CN[i2cn]->C1 = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable2
   \   00000026   0xB2E4             UXTB     R4,R4
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0x4362             MULS     R2,R4,R2
   \   0000002C   0x5889             LDR      R1,[R1, R2]
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
     42                      if(i2cn == i2c0)    SIM->SCGC &= ~(uint32)SIM_SCGC_I2C0_MASK;
   \   00000030   0xB2E4             UXTB     R4,R4
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD106             BNE      ??i2c_Wait_2
   \   00000036   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x....             LDR      R1,??DataTable2_2  ;; 0xfffeffff
   \   0000003C   0x4001             ANDS     R1,R1,R0
   \   0000003E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0xE005             B        ??i2c_Wait_3
     43                      else                SIM->SCGC &= ~(uint32)SIM_SCGC_I2C1_MASK;
   \                     ??i2c_Wait_2: (+1)
   \   00000044   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x....             LDR      R1,??DataTable2_3  ;; 0xfffdffff
   \   0000004A   0x4001             ANDS     R1,R1,R0
   \   0000004C   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000004E   0x6001             STR      R1,[R0, #+0]
     44          
     45                      LED_3_ON;//出错了，闪灯
   \                     ??i2c_Wait_3: (+1)
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2033             MOVS     R0,#+51
   \   00000054   0x.... 0x....      BL       GpioSet
     46          //            BUZZER_TURN;
     47                      carStatus = STOP;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x....             LDR      R1,??DataTable2_4
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
     48          //            IIC_init();
     49          //            IIC_stop();
     50                      if(i2cn == i2c0)    SIM->SCGC |= SIM_SCGC_I2C0_MASK;
   \   0000005E   0xB2E4             UXTB     R4,R4
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0xD107             BNE      ??i2c_Wait_4
   \   00000064   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2180             MOVS     R1,#+128
   \   0000006A   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   0000006C   0x4301             ORRS     R1,R1,R0
   \   0000006E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000070   0x6001             STR      R1,[R0, #+0]
   \   00000072   0xE006             B        ??i2c_Wait_5
     51                      else                SIM->SCGC |= SIM_SCGC_I2C1_MASK;
   \                     ??i2c_Wait_4: (+1)
   \   00000074   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x2180             MOVS     R1,#+128
   \   0000007A   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   0000007C   0x4301             ORRS     R1,R1,R0
   \   0000007E   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000080   0x6001             STR      R1,[R0, #+0]
     52                      I2CN[i2cn]->C1 = I2C_C1_IICEN_MASK;
   \                     ??i2c_Wait_5: (+1)
   \   00000082   0x2080             MOVS     R0,#+128
   \   00000084   0x....             LDR      R1,??DataTable2
   \   00000086   0xB2E4             UXTB     R4,R4
   \   00000088   0x2204             MOVS     R2,#+4
   \   0000008A   0x4362             MULS     R2,R4,R2
   \   0000008C   0x5889             LDR      R1,[R1, R2]
   \   0000008E   0x7088             STRB     R0,[R1, #+2]
     53                      break;
     54                  }
     55              }
     56              I2CN[i2cn]->S |= I2C_S_IICIF_MASK ;
   \                     ??i2c_Wait_1: (+1)
   \   00000090   0x....             LDR      R0,??DataTable2
   \   00000092   0xB2E4             UXTB     R4,R4
   \   00000094   0x2104             MOVS     R1,#+4
   \   00000096   0x4361             MULS     R1,R4,R1
   \   00000098   0x5840             LDR      R0,[R0, R1]
   \   0000009A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000009C   0x2102             MOVS     R1,#+2
   \   0000009E   0x4301             ORRS     R1,R1,R0
   \   000000A0   0x....             LDR      R0,??DataTable2
   \   000000A2   0xB2E4             UXTB     R4,R4
   \   000000A4   0x2204             MOVS     R2,#+4
   \   000000A6   0x4362             MULS     R2,R4,R2
   \   000000A8   0x5880             LDR      R0,[R0, R2]
   \   000000AA   0x70C1             STRB     R1,[R0, #+3]
     57          }
   \   000000AC   0xBD70             POP      {R4-R6,PC}       ;; return
     58          
     59          //启动信号
     60          #define i2c_Start(NUM)             {I2CN[NUM]->C1 |= (I2C_C1_TX_MASK | I2C_C1_MST_MASK);}    //MST 由0变1，产生起始信号，TX = 1 进入发送模式
     61          
     62          //停止信号
     63          #define i2c_Stop(NUM)              {I2CN[NUM]->C1 &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK);}   //MST 由1变0，产生停止信号，TX = 0 进入接收模式
     64          
     65          //重复启动
     66          #define i2c_RepeatedStart(NUM)     {I2CN[NUM]->C1 |= I2C_C1_RSTA_MASK;}
     67          
     68          //进入接收模式(应答,需要接收多个数据，接收最后一个字节前需要禁用应答i2c_DisableAck)
     69          #define i2c_EnterRxMode(NUM)       {I2CN[NUM]->C1 &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK);}  //
     70          
     71          //进入接收模式(不应答,只接收一个字节)
     72          #define i2c_PutinRxMode(NUM)       {I2CN[NUM]->C1 &= ~I2C_C1_TX_MASK; I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
     73          
     74          //禁用应答(接收最后一个字节)
     75          #define i2c_DisableAck(NUM)        {I2CN[NUM]->C1 |= I2C_C1_TXAK_MASK;}
     76          
     77          //写一个字节
     78          #define i2c_write_byte(NUM,data)   {I2CN[NUM]->D = data; i2c_Wait(NUM);}
     79          
     80          
     81          
     82          
     83          //-------------------------------------------------------------------------------------------------------------------
     84          //  @brief      I2C初始化
     85          //  @param      i2cn        I2C模块(i2c0,i2c1)
     86          //  @param      baud        期望的波特率
     87          //  @return                 实际的波特率
     88          //  @return     void
     89          //  @since      v2.0
     90          //  Sample usage:           i2c_init(i2c0,400*1000);     // 初始化i2c0，期望的波特率为400k
     91          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     92          uint32 i2c_init(I2Cn_e i2cn, uint32 baud)
     93          {
   \                     i2c_init: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB0A2             SUB      SP,SP,#+136
   \   00000004   0x0007             MOVS     R7,R0
     94              //查表 ICR 对应的  SCL_divider ，见 《KEA128RM.pdf》第537页的I2C 分频器和保持值
     95              uint16 ICR_2_SCL_divider[0x40]  =
     96              {
     97                  20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68,
     98                  48, 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240,
     99                  160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576, 640, 768, 960,
    100                  640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840
    101              };
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x....             LDR      R1,??DataTable2_5
   \   0000000A   0x2280             MOVS     R2,#+128
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    102          
    103              uint8 mult;
    104          
    105              uint16 scldiv =  0;  //最佳的分频系数
   \   00000010   0x2600             MOVS     R6,#+0
    106          
    107              //需要从 ICR_2_SCL_divider 里找到 与最佳分频系数scldiv最相近的 分频系数
    108              uint8 icr, n;
    109              uint16 min_Dvalue = ~0, Dvalue;
   \   00000012   0x....             LDR      R5,??DataTable2_6  ;; 0xffff
    110          
    111              if(i2cn == i2c0)
   \   00000014   0xB2FF             UXTB     R7,R7
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD10D             BNE      ??i2c_init_0
    112              {
    113                  // 开启时钟
    114                  SIM->SCGC |= SIM_SCGC_I2C0_MASK;           //开启 I2C0时钟
   \   0000001A   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2180             MOVS     R1,#+128
   \   00000020   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000022   0x4301             ORRS     R1,R1,R0
   \   00000024   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000026   0x6001             STR      R1,[R0, #+0]
    115                  //复用引脚
    116                  if(A3 == I2C0_SCL_PIN)
    117                  {
    118                      SIM->PINSEL &= ~(uint32)SIM_PINSEL_I2C0PS_MASK;
   \   00000028   0x....             LDR      R0,??DataTable2_7  ;; 0x4004800c
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x4388             BICS     R0,R0,R1
   \   00000030   0x....             LDR      R1,??DataTable2_7  ;; 0x4004800c
   \   00000032   0x6008             STR      R0,[R1, #+0]
   \   00000034   0xE00D             B        ??i2c_init_1
    119                  }
    120                  else
    121                  {
    122                      SIM->PINSEL |= SIM_PINSEL_I2C0PS_MASK;
    123                  }
    124          
    125              }
    126              else
    127              {
    128                  // 开启时钟
    129                  SIM->SCGC |= SIM_SCGC_I2C1_MASK;           //开启 I2C1时钟
   \                     ??i2c_init_0: (+1)
   \   00000036   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2180             MOVS     R1,#+128
   \   0000003C   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   0000003E   0x4301             ORRS     R1,R1,R0
   \   00000040   0x....             LDR      R0,??DataTable2_1  ;; 0x40048014
   \   00000042   0x6001             STR      R1,[R0, #+0]
    130                  //复用引脚
    131                  if(E1 == I2C1_SCL_PIN)
    132                  {
    133                      SIM->PINSEL1 &= ~(uint32)SIM_PINSEL1_I2C1PS_MASK;
    134                  }
    135                  else
    136                  {
    137                      SIM->PINSEL1 |= SIM_PINSEL1_I2C1PS_MASK;
   \   00000044   0x....             LDR      R0,??DataTable3  ;; 0x40048010
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   0000004C   0x4301             ORRS     R1,R1,R0
   \   0000004E   0x....             LDR      R0,??DataTable3  ;; 0x40048010
   \   00000050   0x6001             STR      R1,[R0, #+0]
    138                  }
    139              }
    140          
    141              // 设置频率
    142          
    143              // I2C baud rate = bus speed (Hz)/(mul × SCL divider)
    144              // SDA hold time = bus period (s) × mul × SDA hold value
    145              // SCL start hold time = bus period (s) × mul × SCL start hold value
    146              // SCL stop hold time = bus period (s) × mul × SCL stop hold value
    147          
    148          
    149              mult = bus_clk_khz*1000/baud/3840;
   \                     ??i2c_init_1: (+1)
   \   00000052   0x....             LDR      R0,??DataTable3_1
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x21FA             MOVS     R1,#+250
   \   00000058   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   0000005A   0x4348             MULS     R0,R1,R0
   \   0000005C   0x9922             LDR      R1,[SP, #+136]
   \   0000005E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000062   0x21F0             MOVS     R1,#+240
   \   00000064   0x0109             LSLS     R1,R1,#+4        ;; #+3840
   \   00000066   0x.... 0x....      BL       __aeabi_uidiv
   \   0000006A   0x4669             MOV      R1,SP
   \   0000006C   0x7048             STRB     R0,[R1, #+1]
    150          
    151              scldiv =  bus_clk_khz * 1000 / ( (1<<mult) * baud );    //最佳的分频系数
   \   0000006E   0x....             LDR      R0,??DataTable3_1
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x21FA             MOVS     R1,#+250
   \   00000074   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000076   0x4348             MULS     R0,R1,R0
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x466A             MOV      R2,SP
   \   0000007C   0x7852             LDRB     R2,[R2, #+1]
   \   0000007E   0x4091             LSLS     R1,R1,R2
   \   00000080   0x9A22             LDR      R2,[SP, #+136]
   \   00000082   0x4351             MULS     R1,R2,R1
   \   00000084   0x.... 0x....      BL       __aeabi_uidiv
   \   00000088   0x0006             MOVS     R6,R0
    152          
    153              n = 0x40;
   \   0000008A   0x2040             MOVS     R0,#+64
   \   0000008C   0x0004             MOVS     R4,R0
    154              while(n)                                                //循环里逐个扫描，找出最接近的 分频系数
   \                     ??i2c_init_2: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD01D             BEQ      ??i2c_init_3
    155              {
    156                  n--;
   \   00000094   0x1E64             SUBS     R4,R4,#+1
    157                  Dvalue = abs(scldiv - ICR_2_SCL_divider[n]);
   \   00000096   0xB2B6             UXTH     R6,R6
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0xB2E4             UXTB     R4,R4
   \   0000009C   0x2102             MOVS     R1,#+2
   \   0000009E   0x4361             MULS     R1,R4,R1
   \   000000A0   0x5A40             LDRH     R0,[R0, R1]
   \   000000A2   0x1A30             SUBS     R0,R6,R0
   \   000000A4   0x.... 0x....      BL       abs
   \   000000A8   0x4669             MOV      R1,SP
   \   000000AA   0x8048             STRH     R0,[R1, #+2]
    158                  if(Dvalue == 0)
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x8840             LDRH     R0,[R0, #+2]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD102             BNE      ??i2c_init_4
    159                  {
    160                      icr = n;
   \   000000B4   0x4668             MOV      R0,SP
   \   000000B6   0x7004             STRB     R4,[R0, #+0]
    161                      break;                                          //退出while循环
   \   000000B8   0xE00A             B        ??i2c_init_3
    162                  }
    163          
    164                  if(Dvalue < min_Dvalue)
   \                     ??i2c_init_4: (+1)
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x8840             LDRH     R0,[R0, #+2]
   \   000000BE   0xB2AD             UXTH     R5,R5
   \   000000C0   0x42A8             CMP      R0,R5
   \   000000C2   0xD2E4             BCS      ??i2c_init_2
    165                  {
    166                      icr = n;
   \   000000C4   0x4668             MOV      R0,SP
   \   000000C6   0x7004             STRB     R4,[R0, #+0]
    167                      min_Dvalue = Dvalue;
   \   000000C8   0x4668             MOV      R0,SP
   \   000000CA   0x8840             LDRH     R0,[R0, #+2]
   \   000000CC   0x0005             MOVS     R5,R0
   \   000000CE   0xE7DE             B        ??i2c_init_2
    168                  }
    169              }
    170          
    171              I2CN[i2cn]->F  = I2C_F_MULT(mult) | I2C_F_ICR(icr);     // I2C分频寄存器
   \                     ??i2c_init_3: (+1)
   \   000000D0   0x4668             MOV      R0,SP
   \   000000D2   0x7840             LDRB     R0,[R0, #+1]
   \   000000D4   0x0181             LSLS     R1,R0,#+6
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   000000DC   0x0E80             LSRS     R0,R0,#+26
   \   000000DE   0x4308             ORRS     R0,R0,R1
   \   000000E0   0x....             LDR      R1,??DataTable2
   \   000000E2   0xB2FF             UXTB     R7,R7
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0x437A             MULS     R2,R7,R2
   \   000000E8   0x5889             LDR      R1,[R1, R2]
   \   000000EA   0x7048             STRB     R0,[R1, #+1]
    172          
    173              // 使能 I2C
    174              I2CN[i2cn]->C1 = ( 0
    175                                 | I2C_C1_IICEN_MASK       //使能I2C
    176                                 //| I2C_C1_IICIE_MASK       //使能中断
    177                               );
   \   000000EC   0x2080             MOVS     R0,#+128
   \   000000EE   0x....             LDR      R1,??DataTable2
   \   000000F0   0xB2FF             UXTB     R7,R7
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0x437A             MULS     R2,R7,R2
   \   000000F6   0x5889             LDR      R1,[R1, R2]
   \   000000F8   0x7088             STRB     R0,[R1, #+2]
    178          
    179              return (  bus_clk_khz * 1000 / ( (1<<mult) * ICR_2_SCL_divider[icr])  );
   \   000000FA   0x....             LDR      R0,??DataTable3_1
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x21FA             MOVS     R1,#+250
   \   00000100   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000102   0x4348             MULS     R0,R1,R0
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0x466A             MOV      R2,SP
   \   00000108   0x7852             LDRB     R2,[R2, #+1]
   \   0000010A   0x4091             LSLS     R1,R1,R2
   \   0000010C   0xAA01             ADD      R2,SP,#+4
   \   0000010E   0x4694             MOV      R12,R2
   \   00000110   0x466A             MOV      R2,SP
   \   00000112   0x7813             LDRB     R3,[R2, #+0]
   \   00000114   0x2202             MOVS     R2,#+2
   \   00000116   0x4353             MULS     R3,R2,R3
   \   00000118   0x4662             MOV      R2,R12
   \   0000011A   0x5AD2             LDRH     R2,[R2, R3]
   \   0000011C   0x4351             MULS     R1,R2,R1
   \   0000011E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000122   0xB023             ADD      SP,SP,#+140
   \   00000124   0xBDF0             POP      {R4-R7,PC}       ;; return
    180          }
    181          
    182          //-------------------------------------------------------------------------------------------------------------------
    183          //  @brief      I2C通信结束后需要调用的函数函数
    184          //  @return     void
    185          //  @since      v2.0
    186          //  @note		如果通信失败，可尝试增大此延时值，确认是否延时导致的
    187          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    188          void i2c_delay(void)
    189          {
   \                     i2c_delay: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    190              volatile uint16 n = 150;     //注意，这个数据太小，会导致读取错误。
   \   00000002   0x2096             MOVS     R0,#+150
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    191          
    192              while(n--);
   \                     ??i2c_delay_0: (+1)
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x1E41             SUBS     R1,R0,#+1
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x8011             STRH     R1,[R2, #+0]
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1F7             BNE      ??i2c_delay_0
    193          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    194          
    195          //-------------------------------------------------------------------------------------------------------------------
    196          //  @brief      读取I2C设备指定地址寄存器的数据
    197          //  @param      i2cn        I2C模块(i2c0、i2c1)
    198          //  @param      SlaveID     从机地址(7位地址)
    199          //  @param      reg         从机寄存器地址
    200          //  @return                 读取的寄存器值
    201          //  @since      v2.0
    202          //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50);//读取0x50地址的数据，从机地址为0x2D
    203          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    204          uint8 i2c_read_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg)
    205          {
   \                     i2c_read_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
    206          
    207              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    208              //地址是低七位
    209              uint8 result;
    210          
    211              i2c_Start(i2cn);                                    //发送启动信号
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4361             MULS     R1,R4,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x2030             MOVS     R0,#+48
   \   00000016   0x4308             ORRS     R0,R0,R1
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x4362             MULS     R2,R4,R2
   \   00000020   0x5889             LDR      R1,[R1, R2]
   \   00000022   0x7088             STRB     R0,[R1, #+2]
    212          
    213              i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
   \   00000024   0x0068             LSLS     R0,R5,#+1
   \   00000026   0x....             LDR      R1,??DataTable4
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0x4362             MULS     R2,R4,R2
   \   0000002E   0x5889             LDR      R1,[R1, R2]
   \   00000030   0x7108             STRB     R0,[R1, #+4]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x.... 0x....      BL       i2c_Wait
    214          
    215              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003A   0x....             LDR      R0,??DataTable4
   \   0000003C   0xB2E4             UXTB     R4,R4
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x4361             MULS     R1,R4,R1
   \   00000042   0x5840             LDR      R0,[R0, R1]
   \   00000044   0x7107             STRB     R7,[R0, #+4]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       i2c_Wait
    216          
    217              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   0000004E   0x....             LDR      R0,??DataTable4
   \   00000050   0xB2E4             UXTB     R4,R4
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x4361             MULS     R1,R4,R1
   \   00000056   0x5840             LDR      R0,[R0, R1]
   \   00000058   0x7881             LDRB     R1,[R0, #+2]
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x4308             ORRS     R0,R0,R1
   \   0000005E   0x....             LDR      R1,??DataTable4
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0x2204             MOVS     R2,#+4
   \   00000064   0x4362             MULS     R2,R4,R2
   \   00000066   0x5889             LDR      R1,[R1, R2]
   \   00000068   0x7088             STRB     R0,[R1, #+2]
    218          
    219              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   0000006A   0x0069             LSLS     R1,R5,#+1
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x4308             ORRS     R0,R0,R1
   \   00000070   0x....             LDR      R1,??DataTable4
   \   00000072   0xB2E4             UXTB     R4,R4
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x4362             MULS     R2,R4,R2
   \   00000078   0x5889             LDR      R1,[R1, R2]
   \   0000007A   0x7108             STRB     R0,[R1, #+4]
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x.... 0x....      BL       i2c_Wait
    220          
    221              i2c_PutinRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   00000084   0x....             LDR      R0,??DataTable4
   \   00000086   0xB2E4             UXTB     R4,R4
   \   00000088   0x2104             MOVS     R1,#+4
   \   0000008A   0x4361             MULS     R1,R4,R1
   \   0000008C   0x5840             LDR      R0,[R0, R1]
   \   0000008E   0x7881             LDRB     R1,[R0, #+2]
   \   00000090   0x20EF             MOVS     R0,#+239
   \   00000092   0x4008             ANDS     R0,R0,R1
   \   00000094   0x....             LDR      R1,??DataTable4
   \   00000096   0xB2E4             UXTB     R4,R4
   \   00000098   0x2204             MOVS     R2,#+4
   \   0000009A   0x4362             MULS     R2,R4,R2
   \   0000009C   0x5889             LDR      R1,[R1, R2]
   \   0000009E   0x7088             STRB     R0,[R1, #+2]
   \   000000A0   0x....             LDR      R0,??DataTable4
   \   000000A2   0xB2E4             UXTB     R4,R4
   \   000000A4   0x2104             MOVS     R1,#+4
   \   000000A6   0x4361             MULS     R1,R4,R1
   \   000000A8   0x5840             LDR      R0,[R0, R1]
   \   000000AA   0x7881             LDRB     R1,[R0, #+2]
   \   000000AC   0x2008             MOVS     R0,#+8
   \   000000AE   0x4308             ORRS     R0,R0,R1
   \   000000B0   0x....             LDR      R1,??DataTable4
   \   000000B2   0xB2E4             UXTB     R4,R4
   \   000000B4   0x2204             MOVS     R2,#+4
   \   000000B6   0x4362             MULS     R2,R4,R2
   \   000000B8   0x5889             LDR      R1,[R1, R2]
   \   000000BA   0x7088             STRB     R0,[R1, #+2]
    222              result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
   \   000000BC   0x....             LDR      R0,??DataTable4
   \   000000BE   0xB2E4             UXTB     R4,R4
   \   000000C0   0x2104             MOVS     R1,#+4
   \   000000C2   0x4361             MULS     R1,R4,R1
   \   000000C4   0x5840             LDR      R0,[R0, R1]
   \   000000C6   0x7900             LDRB     R0,[R0, #+4]
   \   000000C8   0x0006             MOVS     R6,R0
    223              i2c_Wait(i2cn);                                     //等待接收完成
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0xB2C0             UXTB     R0,R0
   \   000000CE   0x.... 0x....      BL       i2c_Wait
    224          
    225              i2c_Stop(i2cn);                                     //发送停止信号
   \   000000D2   0x....             LDR      R0,??DataTable4
   \   000000D4   0xB2E4             UXTB     R4,R4
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x4361             MULS     R1,R4,R1
   \   000000DA   0x5840             LDR      R0,[R0, R1]
   \   000000DC   0x7881             LDRB     R1,[R0, #+2]
   \   000000DE   0x20CF             MOVS     R0,#+207
   \   000000E0   0x4008             ANDS     R0,R0,R1
   \   000000E2   0x....             LDR      R1,??DataTable4
   \   000000E4   0xB2E4             UXTB     R4,R4
   \   000000E6   0x2204             MOVS     R2,#+4
   \   000000E8   0x4362             MULS     R2,R4,R2
   \   000000EA   0x5889             LDR      R1,[R1, R2]
   \   000000EC   0x7088             STRB     R0,[R1, #+2]
    226          
    227              result = I2CN[i2cn]->D;                             //读取数据
   \   000000EE   0x....             LDR      R0,??DataTable4
   \   000000F0   0xB2E4             UXTB     R4,R4
   \   000000F2   0x2104             MOVS     R1,#+4
   \   000000F4   0x4361             MULS     R1,R4,R1
   \   000000F6   0x5840             LDR      R0,[R0, R1]
   \   000000F8   0x7900             LDRB     R0,[R0, #+4]
   \   000000FA   0x0006             MOVS     R6,R0
    228          
    229              i2c_delay();                                        //必须延时一下，否则出错
   \   000000FC   0x.... 0x....      BL       i2c_delay
    230          
    231              return result;
   \   00000100   0x0030             MOVS     R0,R6
   \   00000102   0xB2C0             UXTB     R0,R0
   \   00000104   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    232          }
    233          
    234          //-------------------------------------------------------------------------------------------------------------------
    235          //  @brief      读取I2C设备指定地址寄存器的数据
    236          //  @param      i2cn        I2C模块(i2c0、i2c1)
    237          //  @param      SlaveID     从机地址(7位地址)
    238          //  @param      reg         从机寄存器地址
    239          //  @param      num         读取字节数
    240          //  @param      addr        读取的数据存储的地址
    241          //  @return     void
    242          //  @since      v2.0
    243          //  Sample usage:       	uint8 value = i2c_read_reg(i2c0, 0x2D, 0x50, 10, buf);//读取0x50地址的数据，从机地址为0x2D开始的10个字节
    244          //-------------------------------------------------------------------------------------------------------------------
    245          

   \                                 In section .text, align 2, keep-with-next
    246          uint8 i2c_read_reg_bytes(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 num, uint8 * addr)
    247          {
   \                     i2c_read_reg_bytes: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x001C             MOVS     R4,R3
   \   00000006   0x9E08             LDR      R6,[SP, #+32]
    248              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    249              //地址是低七位
    250              uint8 result;
    251          
    252              i2c_Start(i2cn);                                    //发送启动信号
   \   00000008   0x....             LDR      R0,??DataTable4
   \   0000000A   0xB2ED             UXTB     R5,R5
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x4369             MULS     R1,R5,R1
   \   00000010   0x5840             LDR      R0,[R0, R1]
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x2030             MOVS     R0,#+48
   \   00000016   0x4308             ORRS     R0,R0,R1
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x436A             MULS     R2,R5,R2
   \   00000020   0x5889             LDR      R1,[R1, R2]
   \   00000022   0x7088             STRB     R0,[R1, #+2]
    253          
    254              i2c_write_byte(i2cn, (SlaveID << 1) | MWSR);        //发送从机地址和写位
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x7900             LDRB     R0,[R0, #+4]
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x....             LDR      R1,??DataTable4
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0x436A             MULS     R2,R5,R2
   \   00000032   0x5889             LDR      R1,[R1, R2]
   \   00000034   0x7108             STRB     R0,[R1, #+4]
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x.... 0x....      BL       i2c_Wait
    255          
    256              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x7A00             LDRB     R0,[R0, #+8]
   \   00000042   0x....             LDR      R1,??DataTable4
   \   00000044   0xB2ED             UXTB     R5,R5
   \   00000046   0x2204             MOVS     R2,#+4
   \   00000048   0x436A             MULS     R2,R5,R2
   \   0000004A   0x5889             LDR      R1,[R1, R2]
   \   0000004C   0x7108             STRB     R0,[R1, #+4]
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0
   \   00000052   0x.... 0x....      BL       i2c_Wait
    257          
    258              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   00000056   0x....             LDR      R0,??DataTable4
   \   00000058   0xB2ED             UXTB     R5,R5
   \   0000005A   0x2104             MOVS     R1,#+4
   \   0000005C   0x4369             MULS     R1,R5,R1
   \   0000005E   0x5840             LDR      R0,[R0, R1]
   \   00000060   0x7881             LDRB     R1,[R0, #+2]
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x4308             ORRS     R0,R0,R1
   \   00000066   0x....             LDR      R1,??DataTable4
   \   00000068   0xB2ED             UXTB     R5,R5
   \   0000006A   0x2204             MOVS     R2,#+4
   \   0000006C   0x436A             MULS     R2,R5,R2
   \   0000006E   0x5889             LDR      R1,[R1, R2]
   \   00000070   0x7088             STRB     R0,[R1, #+2]
    259          
    260              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x7900             LDRB     R0,[R0, #+4]
   \   00000076   0x0041             LSLS     R1,R0,#+1
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x4308             ORRS     R0,R0,R1
   \   0000007C   0x....             LDR      R1,??DataTable4
   \   0000007E   0xB2ED             UXTB     R5,R5
   \   00000080   0x2204             MOVS     R2,#+4
   \   00000082   0x436A             MULS     R2,R5,R2
   \   00000084   0x5889             LDR      R1,[R1, R2]
   \   00000086   0x7108             STRB     R0,[R1, #+4]
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0x.... 0x....      BL       i2c_Wait
    261          
    262              i2c_EnterRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   00000090   0x....             LDR      R0,??DataTable4
   \   00000092   0xB2ED             UXTB     R5,R5
   \   00000094   0x2104             MOVS     R1,#+4
   \   00000096   0x4369             MULS     R1,R5,R1
   \   00000098   0x5840             LDR      R0,[R0, R1]
   \   0000009A   0x7881             LDRB     R1,[R0, #+2]
   \   0000009C   0x20E7             MOVS     R0,#+231
   \   0000009E   0x4008             ANDS     R0,R0,R1
   \   000000A0   0x....             LDR      R1,??DataTable4
   \   000000A2   0xB2ED             UXTB     R5,R5
   \   000000A4   0x2204             MOVS     R2,#+4
   \   000000A6   0x436A             MULS     R2,R5,R2
   \   000000A8   0x5889             LDR      R1,[R1, R2]
   \   000000AA   0x7088             STRB     R0,[R1, #+2]
    263          
    264              while(num--)
   \                     ??i2c_read_reg_bytes_0: (+1)
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x1E44             SUBS     R4,R0,#+1
   \   000000B0   0xB2C0             UXTB     R0,R0
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD015             BEQ      ??i2c_read_reg_bytes_1
    265              {
    266                  result = I2CN[i2cn]->D;                         //虚假读取一次，启动接收数据
   \   000000B6   0x....             LDR      R0,??DataTable4
   \   000000B8   0xB2ED             UXTB     R5,R5
   \   000000BA   0x2104             MOVS     R1,#+4
   \   000000BC   0x4369             MULS     R1,R5,R1
   \   000000BE   0x5840             LDR      R0,[R0, R1]
   \   000000C0   0x7900             LDRB     R0,[R0, #+4]
   \   000000C2   0x0007             MOVS     R7,R0
    267                  i2c_Wait(i2cn);                                 //等待接收完成
   \   000000C4   0x0028             MOVS     R0,R5
   \   000000C6   0xB2C0             UXTB     R0,R0
   \   000000C8   0x.... 0x....      BL       i2c_Wait
    268                  *addr = I2CN[i2cn]->D;                         //读取数据
   \   000000CC   0x....             LDR      R0,??DataTable4
   \   000000CE   0xB2ED             UXTB     R5,R5
   \   000000D0   0x2104             MOVS     R1,#+4
   \   000000D2   0x4369             MULS     R1,R5,R1
   \   000000D4   0x5840             LDR      R0,[R0, R1]
   \   000000D6   0x7900             LDRB     R0,[R0, #+4]
   \   000000D8   0x7030             STRB     R0,[R6, #+0]
    269                  i2c_delay();                                    //必须延时一下，否则出错
   \   000000DA   0x.... 0x....      BL       i2c_delay
    270                  addr++;
   \   000000DE   0x1C76             ADDS     R6,R6,#+1
   \   000000E0   0xE7E4             B        ??i2c_read_reg_bytes_0
    271              }
    272              i2c_DisableAck(i2cn);
   \                     ??i2c_read_reg_bytes_1: (+1)
   \   000000E2   0x....             LDR      R0,??DataTable4
   \   000000E4   0xB2ED             UXTB     R5,R5
   \   000000E6   0x2104             MOVS     R1,#+4
   \   000000E8   0x4369             MULS     R1,R5,R1
   \   000000EA   0x5840             LDR      R0,[R0, R1]
   \   000000EC   0x7881             LDRB     R1,[R0, #+2]
   \   000000EE   0x2008             MOVS     R0,#+8
   \   000000F0   0x4308             ORRS     R0,R0,R1
   \   000000F2   0x....             LDR      R1,??DataTable4
   \   000000F4   0xB2ED             UXTB     R5,R5
   \   000000F6   0x2204             MOVS     R2,#+4
   \   000000F8   0x436A             MULS     R2,R5,R2
   \   000000FA   0x5889             LDR      R1,[R1, R2]
   \   000000FC   0x7088             STRB     R0,[R1, #+2]
    273              i2c_PutinRxMode(i2cn);
   \   000000FE   0x....             LDR      R0,??DataTable4
   \   00000100   0xB2ED             UXTB     R5,R5
   \   00000102   0x2104             MOVS     R1,#+4
   \   00000104   0x4369             MULS     R1,R5,R1
   \   00000106   0x5840             LDR      R0,[R0, R1]
   \   00000108   0x7881             LDRB     R1,[R0, #+2]
   \   0000010A   0x20EF             MOVS     R0,#+239
   \   0000010C   0x4008             ANDS     R0,R0,R1
   \   0000010E   0x....             LDR      R1,??DataTable4
   \   00000110   0xB2ED             UXTB     R5,R5
   \   00000112   0x2204             MOVS     R2,#+4
   \   00000114   0x436A             MULS     R2,R5,R2
   \   00000116   0x5889             LDR      R1,[R1, R2]
   \   00000118   0x7088             STRB     R0,[R1, #+2]
   \   0000011A   0x....             LDR      R0,??DataTable4
   \   0000011C   0xB2ED             UXTB     R5,R5
   \   0000011E   0x2104             MOVS     R1,#+4
   \   00000120   0x4369             MULS     R1,R5,R1
   \   00000122   0x5840             LDR      R0,[R0, R1]
   \   00000124   0x7881             LDRB     R1,[R0, #+2]
   \   00000126   0x2008             MOVS     R0,#+8
   \   00000128   0x4308             ORRS     R0,R0,R1
   \   0000012A   0x....             LDR      R1,??DataTable4
   \   0000012C   0xB2ED             UXTB     R5,R5
   \   0000012E   0x2204             MOVS     R2,#+4
   \   00000130   0x436A             MULS     R2,R5,R2
   \   00000132   0x5889             LDR      R1,[R1, R2]
   \   00000134   0x7088             STRB     R0,[R1, #+2]
    274              result = I2CN[i2cn]->D;                             //虚假读取一次，启动接收数据
   \   00000136   0x....             LDR      R0,??DataTable4
   \   00000138   0xB2ED             UXTB     R5,R5
   \   0000013A   0x2104             MOVS     R1,#+4
   \   0000013C   0x4369             MULS     R1,R5,R1
   \   0000013E   0x5840             LDR      R0,[R0, R1]
   \   00000140   0x7900             LDRB     R0,[R0, #+4]
   \   00000142   0x0007             MOVS     R7,R0
    275              i2c_Wait(i2cn);                                     //等待接收完成
   \   00000144   0x0028             MOVS     R0,R5
   \   00000146   0xB2C0             UXTB     R0,R0
   \   00000148   0x.... 0x....      BL       i2c_Wait
    276              i2c_Stop(i2cn);                                     //发送停止信号
   \   0000014C   0x....             LDR      R0,??DataTable4
   \   0000014E   0xB2ED             UXTB     R5,R5
   \   00000150   0x2104             MOVS     R1,#+4
   \   00000152   0x4369             MULS     R1,R5,R1
   \   00000154   0x5840             LDR      R0,[R0, R1]
   \   00000156   0x7881             LDRB     R1,[R0, #+2]
   \   00000158   0x20CF             MOVS     R0,#+207
   \   0000015A   0x4008             ANDS     R0,R0,R1
   \   0000015C   0x....             LDR      R1,??DataTable4
   \   0000015E   0xB2ED             UXTB     R5,R5
   \   00000160   0x2204             MOVS     R2,#+4
   \   00000162   0x436A             MULS     R2,R5,R2
   \   00000164   0x5889             LDR      R1,[R1, R2]
   \   00000166   0x7088             STRB     R0,[R1, #+2]
    277              *addr = I2CN[i2cn]->D;                              //读取数据
   \   00000168   0x....             LDR      R0,??DataTable4
   \   0000016A   0xB2ED             UXTB     R5,R5
   \   0000016C   0x2104             MOVS     R1,#+4
   \   0000016E   0x4369             MULS     R1,R5,R1
   \   00000170   0x5840             LDR      R0,[R0, R1]
   \   00000172   0x7900             LDRB     R0,[R0, #+4]
   \   00000174   0x7030             STRB     R0,[R6, #+0]
    278          
    279              i2c_delay();                                        //必须延时一下，否则出错
   \   00000176   0x.... 0x....      BL       i2c_delay
    280          
    281              return result;
   \   0000017A   0x0038             MOVS     R0,R7
   \   0000017C   0xB2C0             UXTB     R0,R0
   \   0000017E   0xBDFE             POP      {R1-R7,PC}       ;; return
    282          }
    283          
    284          //-------------------------------------------------------------------------------------------------------------------
    285          //  @brief      写入一个字节数据到I2C设备指定寄存器地址
    286          //  @param      i2cn        I2C模块(i2c0、i2c1)
    287          //  @param      SlaveID     从机地址(7位地址)
    288          //  @param      reg         从机寄存器地址
    289          //  @param      Data        数据
    290          //  @return     void
    291          //  @since      v2.0
    292          //  Sample usage:       	i2c_write_reg(i2c0, 0x2D, 0x50,2);     //写入数据2到0x50地址，从机地址为0x2D
    293          //-------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    294          void i2c_write_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 Data)
    295          {
   \                     i2c_write_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    296          
    297              i2c_Start(i2cn);                                    //发送启动信号
   \   0000000A   0x....             LDR      R0,??DataTable4
   \   0000000C   0xB2E4             UXTB     R4,R4
   \   0000000E   0x2104             MOVS     R1,#+4
   \   00000010   0x4361             MULS     R1,R4,R1
   \   00000012   0x5840             LDR      R0,[R0, R1]
   \   00000014   0x7881             LDRB     R1,[R0, #+2]
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0x....             LDR      R1,??DataTable4
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0x4362             MULS     R2,R4,R2
   \   00000022   0x5889             LDR      R1,[R1, R2]
   \   00000024   0x7088             STRB     R0,[R1, #+2]
    298          
    299              i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
   \   00000026   0x0078             LSLS     R0,R7,#+1
   \   00000028   0x....             LDR      R1,??DataTable4
   \   0000002A   0xB2E4             UXTB     R4,R4
   \   0000002C   0x2204             MOVS     R2,#+4
   \   0000002E   0x4362             MULS     R2,R4,R2
   \   00000030   0x5889             LDR      R1,[R1, R2]
   \   00000032   0x7108             STRB     R0,[R1, #+4]
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x.... 0x....      BL       i2c_Wait
    300          
    301              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000003C   0x....             LDR      R0,??DataTable4
   \   0000003E   0xB2E4             UXTB     R4,R4
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x4361             MULS     R1,R4,R1
   \   00000044   0x5840             LDR      R0,[R0, R1]
   \   00000046   0x7105             STRB     R5,[R0, #+4]
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB2C0             UXTB     R0,R0
   \   0000004C   0x.... 0x....      BL       i2c_Wait
    302          
    303              i2c_write_byte(i2cn, Data);                         //发送需要写入的数据
   \   00000050   0x....             LDR      R0,??DataTable4
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0x2104             MOVS     R1,#+4
   \   00000056   0x4361             MULS     R1,R4,R1
   \   00000058   0x5840             LDR      R0,[R0, R1]
   \   0000005A   0x7106             STRB     R6,[R0, #+4]
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xB2C0             UXTB     R0,R0
   \   00000060   0x.... 0x....      BL       i2c_Wait
    304          
    305              i2c_Stop(i2cn);
   \   00000064   0x....             LDR      R0,??DataTable4
   \   00000066   0xB2E4             UXTB     R4,R4
   \   00000068   0x2104             MOVS     R1,#+4
   \   0000006A   0x4361             MULS     R1,R4,R1
   \   0000006C   0x5840             LDR      R0,[R0, R1]
   \   0000006E   0x7881             LDRB     R1,[R0, #+2]
   \   00000070   0x20CF             MOVS     R0,#+207
   \   00000072   0x4008             ANDS     R0,R0,R1
   \   00000074   0x....             LDR      R1,??DataTable4
   \   00000076   0xB2E4             UXTB     R4,R4
   \   00000078   0x2204             MOVS     R2,#+4
   \   0000007A   0x4362             MULS     R2,R4,R2
   \   0000007C   0x5889             LDR      R1,[R1, R2]
   \   0000007E   0x7088             STRB     R0,[R1, #+2]
    306          
    307              i2c_delay();                                        //延时太短的话，可能写出错
   \   00000080   0x.... 0x....      BL       i2c_delay
    308          }
   \   00000084   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40048014         DC32     0x40048014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0xFFFEFFFF         DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0xFFFDFFFF         DC32     0xfffdffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     carStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x4004800C         DC32     0x4004800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40048010         DC32     0x40048010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0014 0x0016      DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
   \              0x0018 0x001A
   \              0x001C 0x001E
   \              0x0022 0x0028
   \              0x001C 0x0020
   \              0x0024 0x0028
   \              0x002C 0x0030
   \              0x0038 0x0044
   \              0x0030       
   \   00000022   0x0038 0x0040      DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
   \              0x0048 0x0050
   \              0x0058 0x0068
   \              0x0080 0x0050
   \              0x0060 0x0070
   \              0x0080 0x0090
   \              0x00A0 0x00C0
   \              0x00F0       
   \   00000040   0x00A0 0x00C0      DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
   \              0x00E0 0x0100
   \              0x0120 0x0140
   \              0x0180 0x01E0
   \              0x0140 0x0180
   \              0x01C0 0x0200
   \              0x0240       
   \   0000005A   0x0280 0x0300      DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
   \              0x03C0 0x0280
   \              0x0300 0x0380
   \              0x0400 0x0480
   \              0x0500 0x0600
   \              0x0780 0x0500
   \   00000072   0x0600 0x0700      DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840
   \              0x0800 0x0900
   \              0x0A00 0x0C00
   \              0x0F00       

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   i2c_Wait
        16   -> GpioSet
       8   i2c_delay
     160   i2c_init
       160   -> __aeabi_memcpy4
       160   -> abs
       160 __aeabi_uidiv
      24   i2c_read_reg
        24   -> i2c_Wait
        24   -> i2c_delay
      32   i2c_read_reg_bytes
        32   -> i2c_Wait
        32   -> i2c_delay
      24   i2c_write_reg
        24   -> i2c_Wait
        24   -> i2c_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable4
     128  ?_0
       8  I2CN
       1  MasterTransmission
       1  SlaveID
     174  i2c_Wait
      26  i2c_delay
     294  i2c_init
     262  i2c_read_reg
     384  i2c_read_reg_bytes
     134  i2c_write_reg

 
     2 bytes in section .bss
     8 bytes in section .data
   128 bytes in section .rodata
 1 318 bytes in section .text
 
 1 318 bytes of CODE  memory
   128 bytes of CONST memory
    10 bytes of DATA  memory

Errors: none
Warnings: none
